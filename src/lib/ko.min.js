(function(e,n){'object'==typeof exports&&'undefined'!=typeof module?module.exports=n():'function'==typeof define&&define.amd?define(n):e.ko=n()})(this,function(){'use strict';//
// Array utilities
//
/* eslint no-cond-assign: 0 */function e(e,n){for(var t=0,i=e.length;t<i;t++)n(e[t],t)}function n(e,n){// IE9
if('function'==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(e,n);for(var t=0,i=e.length;t<i;t++)if(e[t]===n)return t;return-1}function t(e,n,t){for(var o=0,i=e.length;o<i;o++)if(n.call(t,e[o],o))return e[o];return null}function i(e,t){var i=n(e,t);0<i?e.splice(i,1):0===i&&e.shift()}function o(e){e=e||[];for(var t=[],o=0,i=e.length;o<i;o++)0>n(t,e[o])&&t.push(e[o]);return t}function a(e,n){e=e||[];for(var t=[],o=0,i=e.length;o<i;o++)t.push(n(e[o],o));return t}function s(e,n){e=e||[];for(var t=[],o=0,i=e.length;o<i;o++)n(e[o],o)&&t.push(e[o]);return t}function d(e,n){if(n instanceof Array)e.push.apply(e,n);else for(var t=0,i=n.length;t<i;t++)e.push(n[t]);return e}function r(e,t,i){var o=n('function'==typeof e.peek?e.peek():e,t);0>o?i&&e.push(t):!i&&e.splice(o,1)}function l(e){for(var n=[],t=0,i=e.length;t<i;t++)n.push(e[t]);return n}// Go through the items that have been added and deleted and try to find matches between them.
function p(e,n,t){if(e.length&&n.length){var i,o,a,s,d;for(i=o=0;(!t||i<t)&&(s=e[o]);++o){for(a=0;d=n[a];++a)if(s.value===d.value){s.moved=d.index,d.moved=s.index,n.splice(a,1),i=a=0;// Reset failed compares count because we're checking for consecutive failures
break}i+=a}}}// Simple calculation based on Levenshtein distance.
function u(e,n,t){return t='boolean'==typeof t?{dontLimitMoves:t}:t||{},e=e||[],n=n||[],e.length<n.length?c(e,n,Nt,Et,t):c(n,e,Et,Nt,t)}function c(e,n,t,i,o){var a,s,d,r,l,u,c=xt,m=[],g=e.length,h=n.length,f=g+h+1;for(a=0;a<=g;a++)for(r=d,m.push(d=[]),l=c(h,a+(h-g||1)),u=vt(0,a-1),s=u;s<=l;s++)if(!s)d[s]=a+1;else if(!a)// Top row - transform empty array into new array via additions
d[s]=s+1;else if(e[a-1]===n[s-1])d[s]=r[s-1];// copy value (no edit)
else{var b=r[s]||f,y=d[s-1]||f;// not in big (deletion)
d[s]=c(b,y)+1}var v,x=[],N=[],E=[];for(a=g,s=h;a||s;)v=m[a][s]-1,s&&v===m[a][s-1]?N.push(x[x.length]={// added
status:t,value:n[--s],index:s}):a&&v===m[a-1][s]?E.push(x[x.length]={// deleted
status:i,value:e[--a],index:a}):(--s,--a,!o.sparse&&x.push({status:'retained',value:n[s]}));// Set a limit on the number of consecutive non-matching comparisons; having it a multiple of
// smlIndexMax keeps the time complexity of this algorithm linear.
return p(E,N,!o.dontLimitMoves&&10*g),x.reverse()}//
// This becomes ko.options
// --
//
// This is the root 'options', which must be extended by others.
//
// Error handling
// ---
//
// The default onError handler is to re-throw.
function m(e){return Ct.onError?function(){try{return e.apply(this,arguments)}catch(n){Ct.onError(n)}}:e}function g(e){h(function(){Ct.onError(e)},0)}function h(e,n){return setTimeout(m(e),n)}//
// Asynchronous functionality
// ---
function f(e,n){var t;return function(){t||(t=h(function(){t=/* dataItemAlias */void 0,e()},n))}}function b(e,n){var t;return function(){clearTimeout(t),t=h(e,n)}}//
// Detection and Workarounds for Internet Explorer
//
/* eslint no-empty: 0 */// Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
// Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.
// Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.
// If there is a future need to detect specific versions of IE10+, we will amend this.
//
// Object functions
//
function y(e,n){if(n)for(var t in n)n.hasOwnProperty(t)&&(e[t]=n[t]);return e}function v(e,n){for(var t in e)e.hasOwnProperty(t)&&n(t,e[t])}function x(e,n){if(!e)return e;var t={};for(var i in e)e.hasOwnProperty(i)&&(t[i]=n(e[i],i,e));return t}function N(e,n){return e.hasOwnProperty(n)?e[n]:void 0}function E(e,n){if(n||(n=[]),!e||'object'!=typeof e||e.constructor!==Object||-1!==n.indexOf(e))return e;// Anything that makes it below is a plain object that has not yet
// been seen/cloned.
n.push(e);var t={};for(var i in e)e.hasOwnProperty(i)&&(t[i]=E(e[i],n));return t}//
// Prototype Functions
//
function C(e,n){return e.__proto__=n,e}function D(e,n){return null===e||void 0===e||void 0===e[kt]?!1:e[kt]===n||D(e[kt],n);// Walk the prototype chain
}//
// String (and JSON)
//
function T(e){return null===e||void 0===e?'':e.trim?e.trim():e.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,'')}function _(e,n){return e=e||'',!(n.length>e.length)&&e.substring(0,n.length)===n}function S(e,n,t){// replacer and space are optional
if(!JSON||!JSON.stringify)throw new Error('Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don\'t support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js');return JSON.stringify('function'==typeof e?e():e,n,t)}//
// ES6 Symbols
//
function I(e){return At?Symbol(e):e}//
// DOM - CSS
//
// For details on the pattern for changing node classes
// see: https://github.com/knockout/knockout/issues/1597
function k(n,t,i){var o;t&&('object'==typeof n.classList?(o=n.classList[i?'add':'remove'],e(t.match(Bt),function(e){o.call(n.classList,e)})):'string'==typeof n.className.baseVal?w(n.className,'baseVal',t,i):w(n,'className',t,i))}function w(n,t,i,o){// obj/prop is either a node/'className' or a SVGAnimatedString/'baseVal'.
var a=n[t].match(Bt)||[];e(i.match(Bt),function(e){r(a,e,o)}),n[t]=a.join(' ')}//
// jQuery
//
// TODO: deprecate in favour of options.$
//
// Information about the DOM
//
function O(e,n){if(e===n)return(/* allowUnbalanced: */!0/* notifyChange *//* notifyChange *//* allowUnset *//* allowUnset */);if(11===e.nodeType)return!1;// Fixes issue #1162 - can't use node.contains for document fragments on IE8
if(n.contains)return n.contains(1===e.nodeType?e:e.parentNode);if(n.compareDocumentPosition)return 16==(16&n.compareDocumentPosition(e));for(;e&&e!=n;)e=e.parentNode;return!!e}function A(e){return O(e,e.ownerDocument.documentElement)}function B(e){return!!t(e,A)}function P(e){// For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
// Possible future optimization: If we know it's an element from an XHTML document (not HTML),
// we don't need to do the .toLowerCase() as it will always be lower case anyway.
return e&&e.tagName&&e.tagName.toLowerCase()}function V(e){return window.HTMLElement?e instanceof HTMLElement:e&&e.tagName&&1===e.nodeType}function R(e){return window.DocumentFragment?e instanceof DocumentFragment:e&&11===e.nodeType}//
// DOM node data
//
//
/**
 * --- Legacy getter/setter (may cause memory leaks) ---
 */function L(e,n){var t=e[Vt],i=t&&'null'!==t&&Dt[t];if(!i){if(!n)return;t=e[Vt]='ko'+Rt++,Dt[t]={}}return Dt[t]}/**
 * WeakMap get/set/clear
 *//**
 * Create a unique key-string identifier.
 * FIXME: This should be deprecated.
 */function $(){return Rt++ +Vt}function M(e,n){var t=Tt(e,$t);return void 0===t&&n&&(t=[],_t(e,$t,t)),t}function F(e){_t(e,$t,void 0)}function W(e){// Run all the dispose callbacks
var n=M(e,!1);if(n){n=n.slice(0);// Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
for(var t=0;t<n.length;t++)n[t](e)}// Erase the DOM data
St(e);// Perform cleanup needed by external libraries (currently only jQuery, but can be extended)
for(var t=0,i=jt.length;t<i;++t)jt[t](e);// Clear any immediate-child comment nodes, as these wouldn't have been found by
// node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
Ft[e.nodeType]&&U(e)}function U(e){for(var n,t=e.firstChild;n=t;)t=n.nextSibling,8===n.nodeType&&W(n)}// Exports
function j(e,n){if('function'!=typeof n)throw new Error('Callback must be a function');M(e,!0).push(n)}function H(e,n){var t=M(e,!1);t&&(i(t,n),0==t.length&&F(e))}function K(e){// First clean this node, where applicable
if(Mt[e.nodeType]&&(W(e),Ft[e.nodeType])){// Clone the descendants list in case it changes during iteration
var n=[];d(n,e.getElementsByTagName('*'));for(var t=0,i=n.length;t<i;t++)W(n[t])}return e}function Q(e){K(e),e.parentNode&&e.parentNode.removeChild(e)}// Expose supplemental node cleaning functions.
// Special support for jQuery here because it's so commonly used.
// Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
// so notify it to tear down any resources associated with the node & descendants here.
function q(e){var n=Pt?Pt.cleanData:null;n&&n([e])}function z(e,n){if('input'!==P(e)||!e.type)return!1;if('click'!=n.toLowerCase())return!1;var t=e.type;return'checkbox'==t||'radio'==t}// Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406
function G(e,n,t){var i=m(t),o=It&&Kt[n];if(!Ct.useOnlyNativeEvents&&!o&&Pt)Pt(e).bind(n,i);else if(!o&&'function'==typeof e.addEventListener)e.addEventListener(n,i,!1);else if('undefined'!=typeof e.attachEvent){var a=function(n){i.call(e,n)},s='on'+n;e.attachEvent(s,a),j(e,function(){e.detachEvent(s,a)})}else throw new Error('Browser doesn\'t support addEventListener or attachEvent')}function J(e,n){if(!(e&&e.nodeType))throw new Error('element must be a DOM node when calling triggerEvent');// For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the
// event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)
// IE doesn't change the checked state when you trigger the click event using "fireEvent".
// In both cases, we'll use the click method instead.
var t=z(e,n);if(!Ct.useOnlyNativeEvents&&Pt&&!t)Pt(e).trigger(n);else if('function'==typeof document.createEvent){if('function'==typeof e.dispatchEvent){var i=Ut[n]||'HTMLEvents',o=document.createEvent(i);o.initEvent(n,!0,!0,window,0,0,0,0,0,!1,!1,!1,!1,0,e),e.dispatchEvent(o)}else throw new Error('The supplied element doesn\'t support dispatchEvent');}else if(t&&e.click)e.click();else if('undefined'!=typeof e.fireEvent)e.fireEvent('on'+n);else throw new Error('Browser doesn\'t support triggering events')}//
//  DOM node manipulation
//
function Y(e,n){// Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile
// them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that
// new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
// leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
// So, this function translates the old "map" output array into its best guess of the set of current DOM nodes.
//
// Rules:
//   [A] Any leading nodes that have been removed should be ignored
//       These most likely correspond to memoization nodes that were already removed during binding
//       See https://github.com/knockout/knockout/pull/440
//   [B] Any trailing nodes that have been remove should be ignored
//       This prevents the code here from adding unrelated nodes to the array while processing rule [C]
//       See https://github.com/knockout/knockout/pull/1903
//   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,
//       and include any nodes that have been inserted among the previous collection
if(e.length){// Rule [A]
for(n=8===n.nodeType&&n.parentNode||n;e.length&&e[0].parentNode!==n;)e.splice(0,1);// Rule [B]
for(;1<e.length&&e[e.length-1].parentNode!==n;)e.length--;// Rule [C]
if(1<e.length){var t=e[0],i=e[e.length-1];// Replace with the actual new continuous node set
for(e.length=0;t!==i;)e.push(t),t=t.nextSibling;e.push(i)}}return e}function X(e,n){7>It?e.setAttribute('selected',n):e.selected=n}function Z(e){// Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209
if(9<=It){// For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container
var n=1==e.nodeType?e:e.parentNode;n.style&&(n.style.zoom=n.style.zoom)}}function ee(e){// Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
// (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
// Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)
if(It){var n=e.style.width;e.style.width=0,e.style.width=n}}/* eslint no-cond-assign: 0 *///
// Virtual Elements
//
//
// "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
// may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
// If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
// of that virtual hierarchy
//
// The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
// without having to scatter special cases all over the binding and templating code.
// IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
// but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
// So, use node.text where available, and node.nodeValue elsewhere
function ne(e){return 8==e.nodeType&&qt.test(Qt?e.text:e.nodeValue)}function te(e){return 8==e.nodeType&&zt.test(Qt?e.text:e.nodeValue)}function ie(e,n){for(var t=e,i=1,o=[];t=t.nextSibling;){if(te(t)&&(i--,0==i))return o;o.push(t),ne(t)&&i++}if(!n)throw new Error('Cannot find closing comment tag to match: '+e.nodeValue);return null}function oe(e,n){var t=ie(e,n);return t?0<t.length?t[t.length-1].nextSibling:e.nextSibling:null;// Must have no matching end comment, and allowUnbalanced is true
}function ae(e){// e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
//       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
var n=e.firstChild,t=null;if(n)do if(t)// We already hit an unbalanced node and are now just scooping up all subsequent nodes
t.push(n);else if(ne(n)){var i=oe(n,!0);i?n=i:t=[n]}else te(n)&&(t=[n]);while(n=n.nextSibling);return t}function se(e){return ne(e)?ie(e):e.childNodes}function de(e){if(!ne(e))Ee(e);else for(var n=se(e),t=0,i=n.length;t<i;t++)Q(n[t])}function re(e,n){if(!ne(e))ye(e,n);else{de(e);// Must be the next sibling, as we just emptied the children
for(var t=e.nextSibling,o=0,i=n.length;o<i;o++)t.parentNode.insertBefore(n[o],t)}}function le(e,n){ne(e)?e.parentNode.insertBefore(n,e.nextSibling):e.firstChild?e.insertBefore(n,e.firstChild):e.appendChild(n)}function pe(e,n,t){t?ne(e)?e.parentNode.insertBefore(n,t.nextSibling):t.nextSibling?e.insertBefore(n,t.nextSibling):e.appendChild(n):le(e,n)}function ue(e){return ne(e)?!e.nextSibling||te(e.nextSibling)?null:e.nextSibling:e.firstChild}function ce(e){return ne(e)&&(e=oe(e)),e.nextSibling&&te(e.nextSibling)?null:e.nextSibling}function me(e){var n=0;do if(8===e.nodeType){if(!ne(e))te(e)&&n++;else if(0==--n)return e;}else if(0==n)return e;while(e=e.previousSibling)}function ge(e){var n=(Qt?e.text:e.nodeValue).match(qt);return n?n[1]:null}function he(e){// Workaround for https://github.com/SteveSanderson/knockout/issues/155
// (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
// that are direct descendants of <ul> into the preceding <li>)
if(Gt[P(e)]){// Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
// must be intended to appear *after* that child, so move them there.
var n=e.firstChild;if(n)do if(1===n.nodeType){var t=ae(n);if(t)for(var o=n.nextSibling,a=0;a<t.length;a++)o?e.insertBefore(t[a],o):e.appendChild(t[a]);// Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
}while(n=n.nextSibling)}}//
// DOM manipulation
//
/* eslint no-empty: 0 */function fe(e){for(var n=l(e),t=n[0]&&n[0].ownerDocument||document,o=t.createElement('div'),a=0,i=n.length;a<i;a++)o.appendChild(K(n[a]));// Ensure it's a real array, as we're about to reparent the nodes and
// we don't want the underlying collection to change while we're doing that.
return o}function be(e,n){for(var t,o=0,i=e.length,a=[];o<i;o++)t=e[o].cloneNode(!0),a.push(n?K(t):t);return a}function ye(e,n){if(Ee(e),n)for(var t=0,i=n.length;t<i;t++)e.appendChild(n[t])}function ve(e,n){var t=e.nodeType?[e]:e;if(0<t.length){for(var o=t[0],a=o.parentNode,s=0,i=n.length;s<i;s++)a.insertBefore(n[s],o);for(s=0,i=t.length;s<i;s++)Q(t[s])}}function xe(e,n){// Workaround IE 6/7 issue
// - https://github.com/SteveSanderson/knockout/issues/197
// - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
if(e.name=n,7>=It)try{e.mergeAttributes(document.createElement('<input name=\''+e.name+'\'/>'),!1)}catch(n){}// For IE9 with doc mode "IE9 Standards" and browser mode "IE9 Compatibility View"
}function Ne(e,n){var t='function'==typeof n?n():n;(null===t||void 0===t)&&(t='');// We need there to be exactly one child: a text node.
// If there are no children, more than one, or if it's not a text node,
// we'll clear everything and create a single text node.
var i=ue(e);!i||3!=i.nodeType||ce(i)?re(e,[e.ownerDocument.createTextNode(t)]):i.data=t,Z(e)}function Ee(e){for(;e.firstChild;)Q(e.firstChild)}//
// HTML-based manipulation
//
function Ce(e){var n=e.match(/^<([a-z]+)[ >]/);return n&&ti[n[1]]||Xt}function De(e,n){n||(n=document);var t=n.parentWindow||n.defaultView||window,i=T(e).toLowerCase(),o=n.createElement('div'),a=Ce(i),s=a[0],d='ignored<div>'+a[1]+e+a[2]+'</div>';// Based on jQuery's "clean" function, but only accounting for table-related elements.
// If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly
// Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
// a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
// This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
// (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.
// Trim whitespace, otherwise indexOf won't work as expected
// Go to html and back, then peel off extra wrappers
// Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
// Move to the right depth
for('function'==typeof t.innerShiv?o.appendChild(t.innerShiv(d)):o.innerHTML=d;s--;)o=o.lastChild;return l(o.lastChild.childNodes)}function Te(e,n){n||(n=document);var t=n.createElement('template');return t.innerHTML=e,l(t.content.childNodes)}function _e(e,n){// jQuery's "parseHTML" function was introduced in jQuery 1.8.0 and is a documented public API.
if(Pt.parseHTML)return Pt.parseHTML(e,n)||[];// Ensure we always return an array and never null
// For jQuery < 1.8.0, we fall back on the undocumented internal "clean" function.
var t=Pt.clean([e],n);// As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
// Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
// Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
if(t&&t[0]){for(// Find the top-most parent element that's a direct child of a document fragment
var i=t[0];i.parentNode&&11!==i.parentNode.nodeType/* i.e., DocumentFragment */;)i=i.parentNode;// ... then detach it
i.parentNode&&i.parentNode.removeChild(i)}return t}/**
 * parseHtmlFragment converts a string into an array of DOM Nodes.
 * If supported, it uses <template>-tag parsing, falling back on
 * jQuery parsing (if jQuery is present), and finally on a
 * straightforward parser.
 *
 * @param  {string} html            To be parsed.
 * @param  {Object} documentContext That owns the executing code.
 * @return {[DOMNode]}              Parsed DOM Nodes
 */function Se(e,n){// Prefer <template>-tag based HTML parsing.
return ii?Te(e,n):// Benefit from jQuery's on old browsers, where possible
// NOTE: jQuery's HTML parsing fails on element names like tr-*.
// See: https://github.com/jquery/jquery/pull/1988
Pt?_e(e,n):// ... otherwise, this simple logic will do in most common cases.
De(e,n)}/**
  * setHtml empties the node's contents, unwraps the HTML, and
  * sets the node's HTML using jQuery.html or parseHtmlFragment
  *
  * @param {DOMNode} node Node in which HTML needs to be set
  * @param {DOMNode} html HTML to be inserted in node
  * @returns undefined
  */function Ie(e,n){if(Ee(e),'function'==typeof n&&(n=n()),null!==n&&void 0!==n)// If the browser supports <template> tags, prefer that, as
// it obviates all the complex workarounds of jQuery.
//
// However, jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
// for example <tr> elements which are not normally allowed to exist on their own.
// If you've referenced jQuery (and template tags are not supported) we'll use that rather than duplicating its code.
if('string'!=typeof n&&(n=n.toString()),Pt&&!ii)Pt(e).html(n);else{// ... otherwise, use KO's own parsing logic.
var t=Se(n,e.ownerDocument);if(8===e.nodeType)null===n?de(e):re(e,t);else for(var o=0;o<t.length;o++)e.appendChild(t[o])}}//
// Memoization
//
function ke(){return(0|4294967296*(1+Math.random())).toString(16).substring(1)}function we(){return ke()+ke()}function Oe(e,n){if(e)if(8==e.nodeType){var t=Ve(e.nodeValue);null!=t&&n.push({domNode:e,memoId:t})}else if(1==e.nodeType)for(var o=0,i=e.childNodes,a=i.length;o<a;o++)Oe(i[o],n)}function Ae(e){if('function'!=typeof e)throw new Error('You can only pass a function to memoization.memoize()');var n=we();return oi[n]=e,'<!--[ko_memo:'+n+']-->'}function Be(e,n){var t=oi[e];if(void 0===t)throw new Error('Couldn\'t find any memo with ID '+e+'. Perhaps it\'s already been unmemoized.');try{return t.apply(null,n||[]),!0}finally{delete oi[e]}}function Pe(e,n){var t=[];Oe(e,t);for(var o=0,i=t.length;o<i;o++){var a=t[o].domNode,s=[a];n&&d(s,n),Be(t[o].memoId,s),a.nodeValue='',a.parentNode&&a.parentNode.removeChild(a)}}function Ve(e){var n=e.match(/^\[ko_memo\:(.*?)\]$/);return n?n[1]:null}function Re(){if(di)// nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue
for(var e,n=di,t=0;li<di;)if(e=si[li++]){if(li>n){if(5e3<=++t){li=di,g(Error('\'Too much recursion\' after processing '+t+' task groups.'));break}n=di}try{e()}catch(e){g(e)}}// Each mark represents the end of a logical group of tasks and the number of these groups is
// limited to prevent unchecked recursion.
}function Le(){Re(),li=di=si.length=0}function $e(){Ct.taskScheduler(Le)}function Me(e){return di||$e(),si[di++]=e,ri++}function Fe(e){var n=e-(ri-di);n>=li&&n<di&&(si[n]=null)}// For testing only: reset the queue and return the previous queue length
//
//  Defer Updates
//  ===
//
function je(e){e._deferUpdates||(e._deferUpdates=!0,e.limit(function(n){var t;return function(){Fe(t),t=Me(n),e.notifySubscribers(void 0,'dirty')}}))}//
// Observable extenders
// ---
//
function We(e,n){return!!(null===e||typeof e in ci)&&e===n}/*
                --- DEFAULT EXTENDERS ---
 */// Change when notifications are published.
/* eslint no-cond-assign: 0 */function Ue(e,n,t){this._target=e,this.callback=n,this.disposeCallback=t,this.isDisposed=!1}function He(){Ot(this,hi),hi.init(this)}function Ke(e){return null!=e&&'function'==typeof e.subscribe&&'function'==typeof e.notifySubscribers}//
// dependencyDetection
// ---
//
// In KO 3.x, dependencyDetection was also known as computedContext.
//
// Return a unique ID that can be assigned to an observable for dependency tracking.
// Theoretically, you could eventually overflow the number storage size, resulting
// in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53
// or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would
// take over 285 years to reach that number.
// Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html
function Qe(){return++yi}function qe(e){fi.push(bi),bi=e}function ze(){bi=fi.pop()}function Ge(e){if(bi){if(!Ke(e))throw new Error('Only subscribable things can act as dependencies');bi.callback.call(bi.callbackTarget,e,e._id||(e._id=Qe()))}}function Je(e,n,t){try{return qe(),e.apply(n,t||[])}finally{ze()}}function Ye(){if(bi)return bi.computed.getDependenciesCount()}function Xe(){if(bi)return bi.isInitial}function Ze(e){function n(){return 0<arguments.length?(n.isDifferent(n[xi],arguments[0])&&(n.valueWillMutate(),n[xi]=arguments[0],n.valueHasMutated()),this):(Ge(n),n[xi])}return n[xi]=e,wt||y(n,He.fn),He.fn.init(n),Ot(n,Ze.fn),Ct.deferUpdates&&je(n),n}// Define prototype for observables
// Moved out of "limit" to avoid the extra closure
function en(e,n){n&&n!==gi?'beforeChange'===n?this._limitBeforeChange(e):this._origNotifySubscribers(e,n):this._limitChange(e)}// Add `limit` function to the subscribable prototype
function nn(e){return D(e,Ze)}function tn(e){return nn(e)?e():e}function on(e){return nn(e)?e.peek():e}function an(e){// Observable
// Anything else
return'function'==typeof e&&e[Ni]===Ze||'function'==typeof e&&/* && (instance[protoProperty] === ko.dependentObservable) */e.hasWriteFunction;// Writeable dependent observable
}//
// Observable Array - Change Tracking Extender
// ---
//
/* eslint no-fallthrough: 0*/function sn(e,n){function t(){// Calling 'trackChanges' multiple times is the same as calling it once
if(!a){a=!0;// Intercept "notifySubscribers" to track how many times it was called.
var n=e.notifySubscribers;e.notifySubscribers=function(e,t){return t&&t!==gi||++d,n.apply(this,arguments)};// Each time the array changes value, capture a clone so that on the next
// change it's possible to produce a diff
var t=[].concat(e.peek()||[]);s=null,o=e.subscribe(function(n){// Compute the diff and issue notifications, but only if someone is listening
if(n=[].concat(n||[]),e.hasSubscriptionsForEvent(Ei))var o=i(t,n);// Eliminate references to the old, removed items, so they can be GCed
t=n,s=null,d=0,o&&o.length&&e.notifySubscribers(o,Ei)})}}function i(n,t){return(!s||1<d)&&(s=sn.compareArrays(n,t,e.compareArrayOptions)),s}// Only modify the target observable once
if(e.compareArrayOptions={},n&&'object'==typeof n&&y(e.compareArrayOptions,n),e.compareArrayOptions.sparse=!0,!e.cacheDiffForKnownOperation){var o,a=!1,s=null,d=0,r=e.beforeSubscriptionAdd,l=e.afterSubscriptionRemove;// Watch "subscribe" calls, and for array change events, ensure change tracking is enabled
e.beforeSubscriptionAdd=function(n){r&&r.call(e,n),n===Ei&&t()},e.afterSubscriptionRemove=function(n){l&&l.call(e,n),n!==Ei||e.hasSubscriptionsForEvent(Ei)||(o&&o.dispose(),o=null,a=!1)},e.cacheDiffForKnownOperation=function(e,n,t){function i(e,n,t){return l[l.length]={status:e,value:n,index:t}}var o,r;// Only run if we're currently tracking changes for this observable array
// and there aren't any pending deferred notifications.
if(a&&!d){var l=[],u=e.length,c=t.length,m=0;switch(n){case'push':m=u;case'unshift':for(o=0;o<c;o++)i('added',t[o],m+o);break;case'pop':m=u-1;case'shift':u&&i('deleted',e[m],m);break;case'splice':// Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
var g=xt(vt(0,0>t[0]?u+t[0]:t[0]),u),h=1===c?u:xt(g+(t[1]||0),u),f=g+c-2,b=vt(h,f),y=[],v=[];for(o=g,r=2;o<b;++o,++r)o<h&&v.push(i('deleted',e[o],o)),o<f&&y.push(i('added',t[r],o));p(v,y);break;default:return;}s=l}}}}// Expose compareArrays for testing.
//
// Observable Arrays
// ===
//
function dn(e){if(e=e||[],'object'!=typeof e||!('length'in e))throw new Error('The argument passed when initializing an observable array must be an array, or null, or undefined.');var n=Ze(e);// ^== result.extend({ trackArrayChanges: true })
return Ot(n,dn.fn),sn(n),n}// Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)
function rn(e){if(0==arguments.length)throw new Error('When calling ko.toJS, pass the object you want to convert.');// We just unwrap everything at every level in the object graph
return ln(e,function(e){// Loop because an observable's value might in turn be another observable wrapper
for(var n=0;nn(e)&&n<Ci;n++)e=e();return e})}function ln(e,n,t){t=t||new un,e=n(e);var i='object'==typeof e&&null!==e&&void 0!==e&&!(e instanceof RegExp)&&!(e instanceof Date)&&!(e instanceof String)&&!(e instanceof Number)&&!(e instanceof Boolean);if(!i)return e;var o=e instanceof Array?[]:{};return t.save(e,o),pn(e,function(i){var a=n(e[i]);switch(typeof a){case'boolean':case'number':case'string':case'function':o[i]=a;break;case'object':case'undefined':var s=t.get(a);o[i]=void 0===s?ln(a,n,t):s;}}),o}function pn(e,n){if(e instanceof Array){for(var t=0;t<e.length;t++)n(t);// For arrays, also respect toJSON property for custom mappings (fixes #278)
'function'==typeof e.toJSON&&n('toJSON')}else for(var i in e)n(i)}function un(){this.keys=[],this.values=[]}function cn(e,n,t){function i(){if(0<arguments.length){if('function'==typeof o)o.apply(a.evaluatorFunctionTarget,arguments);else throw new Error('Cannot write a value to a computed unless you specify a \'write\' option. If you wish to read the current value, don\'t pass any parameters.');return this;// Permits chained assignments
}return Ge(i),(a.isStale||a.isSleeping&&i.haveDependenciesChanged())&&i.evaluateImmediate(),a.latestValue}if('object'==typeof e?t=e:(t=t||{},e&&(t.read=e)),'function'!=typeof t.read)throw Error('Pass a function that returns the value of the computed');var o=t.write,a={latestValue:void 0,isStale:!0,isBeingEvaluated:!1,suppressDisposalUntilDisposeWhenReturnsFalse:!1,isDisposed:!1,pure:!1,isSleeping:!1,readFunction:t.read,evaluatorFunctionTarget:n||t.owner,disposeWhenNodeIsRemoved:t.disposeWhenNodeIsRemoved||t.disposeWhenNodeIsRemoved||null,disposeWhen:t.disposeWhen||t.disposeWhen,domNodeDisposalCallback:null,dependencyTracking:{},dependenciesCount:0,evaluationTimeoutInstance:null};return i[Di]=a,i.hasWriteFunction='function'==typeof o,wt||y(i,He.fn),He.fn.init(i),Ot(i,cn.fn),t.pure?(a.pure=!0,a.isSleeping=!0,y(i,Ti)):t.deferEvaluation&&y(i,_i),Ct.deferUpdates&&mi.deferred(i,!0),Ct.debug&&(i._options=t),a.disposeWhenNodeIsRemoved&&(a.suppressDisposalUntilDisposeWhenReturnsFalse=!0,!a.disposeWhenNodeIsRemoved.nodeType&&(a.disposeWhenNodeIsRemoved=null)),a.isSleeping||t.deferEvaluation||i.evaluateImmediate(),a.disposeWhenNodeIsRemoved&&i.isActive()&&j(a.disposeWhenNodeIsRemoved,a.domNodeDisposalCallback=function(){i.dispose()}),i}// Utility function that disposes a given dependencyTracking entry
function mn(e,n){null!==n&&n.dispose&&n.dispose()}// This function gets called each time a dependency is detected while evaluating a computed.
// It's factored out as a shared function to avoid creating unnecessary function instances during evaluation.
function gn(e,n){var t=this.computedObservable,i=t[Di];i.isDisposed||(this.disposalCount&&this.disposalCandidates[n]?(t.addDependencyTracking(n,e,this.disposalCandidates[n]),this.disposalCandidates[n]=null,--this.disposalCount):!i.dependencyTracking[n]&&t.addDependencyTracking(n,e,i.isSleeping?{_target:e}:t.subscribeToDependency(e)))}function hn(e,n){return'function'==typeof e?cn(e,n,{pure:!0}):(e=y({},e),e.pure=!0,cn(e,n))}//
// tko.computed - Exports
//
// knockout -> tko changes:
//      Deprecates `dependentObservable` (use `computed`)
//
function fn(){}/**
 * @ operator - recursively call the identifier if it's a function
 * @param  {operand} a ignored
 * @param  {operand} b The variable to be called (if a function) and unwrapped
 * @return {value}   The result.
 *//**
 * Break a binding string (data-bind='x: val, y: ..') into a stable array
 * of {key: value}.
 */function bn(e){// Trim leading and trailing spaces from the string
var n=T(e);// Trim braces '{' surrounding the whole object literal
123===n.charCodeAt(0)&&(n=n.slice(1,-1));// Split into tokens
var t,o=[],a=n.match(Fi),s=[],d=0;if(!a)return[];// Append a comma so that we don't need a separate code block to deal with the last item
a.push(',');for(var r,l,p=0;r=a[p];++p){// A comma signals the end of a key/value pair if depth is zero
if(l=r.charCodeAt(0),44===l){// ","
if(0>=d){o.push(t&&s.length?{key:t,value:s.join('')}:{unknown:t||s.join('')}),t=d=0,s=[];continue}// Simply skip the colon that separates the name and value
}else if(58===l){// ":"
if(!d&&!t&&1===s.length){t=s.pop();continue}// A set of slashes is initially matched as a regular expression, but could be division
}else if(47===l&&p&&1<r.length){// "/"
// Look at the end of the previous token to determine if the slash is actually division
var i=a[p-1].match(ji);i&&!Wi[i[0]]&&(n=n.substr(n.indexOf(r)+1),a=n.match(Fi),a.push(','),p=-1,r='/')}else 40===l||123===l||91===l?++d:41===l||125===l||93===l?--d:t||s.length||34!==l&&39!==l||(r=r.slice(1,-1));s.push(r)}return o}// Tracks component loads that have already completed
function yn(e,n){var t,i=N(zi,e);i?i.subscribe(n):(i=zi[e]=new He,i.subscribe(n),vn(e,function(n,o){var a=!!(o&&o.synchronous);Gi[e]={definition:n,isSynchronousComponent:a},delete zi[e],t||a?i.notifySubscribers(n):Me(function(){i.notifySubscribers(n)})}),t=!0)}function vn(e,n){xn('getConfig',[e],function(t){t?xn('loadComponent',[e,t],function(e){n(e,t)}):n(null,null)})}function xn(e,n,t,i){i||(i=Ji.loaders.slice(0));// Try the next candidate
var o=i.shift();if(o){var a=o[e];if(a){var s=!1,d=a.apply(o,n.concat(function(o){s?t(null):null===o?xn(e,n,t,i):t(o)}));// Currently, loaders may not return anything synchronously. This leaves open the possibility
// that we'll extend the API to support synchronous return values in the future. It won't be
// a breaking change, because currently no loader is allowed to return anything except undefined.
if(void 0!==d&&(s=!0,!o.suppressLoaderExceptions))throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.')}else xn(e,n,t,i)}else t(null)}function Nn(e){return Yi.hasOwnProperty(e)}// Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it
// into the standard component definition format:
//    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.
// Since both template and viewModel may need to be resolved asynchronously, both tasks are performed
// in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,
// so this is implemented manually below.
function En(e,n,t,i){var o={},a=2,s=function(){0==--a&&i(o)},d=t.template,r=t.viewModel;d?_n(n,d,function(n){Ji._getFirstResultFromLoaders('loadTemplate',[e,n],function(e){o.template=e,s()})}):s(),r?_n(n,r,function(n){Ji._getFirstResultFromLoaders('loadViewModel',[e,n],function(e){o[Zi]=e,s()})}):s()}function Cn(e,n,t){if('string'==typeof n)t(Se(n));else if(n instanceof Array)t(n);else if(R(n))t(l(n.childNodes));else if(n.element){var i=n.element;if(V(i))t(Tn(i));else if('string'==typeof i){// Element ID - find it, then copy its child nodes
var o=document.getElementById(i);o?t(Tn(o)):e('Cannot find element with ID '+i)}else e('Unknown element type: '+i)}else e('Unknown template value: '+n)}function Dn(e,n,t){if('function'==typeof n)t(function(e/*, componentInfo */){return new n(e)});else if('function'==typeof n[Zi])t(n[Zi]);else if('instance'in n){// Fixed object instance - promote to createViewModel format for API consistency
var i=n.instance;t(function()/* params, componentInfo */{return i})}else'viewModel'in n?Dn(e,n.viewModel,t):e('Unknown viewModel value: '+n)}function Tn(e){switch(P(e)){case'script':return Se(e.text);case'textarea':return Se(e.value);case'template':// For browsers with proper <template> element support (i.e., where the .content property
// gives a document fragment), use that document fragment.
if(R(e.content))return be(e.content.childNodes);}// Regular elements such as <div>, and <template> elements on old browsers that don't really
// understand <template> and just treat it as a regular container
return be(e.childNodes)}function _n(e,n,t){'string'==typeof n.require?window.amdRequire||window.require?(window.amdRequire||window.require)([n.require],t):e('Uses require, but no AMD loader is present'):t(n)}function Sn(e){return function(n){throw new Error('Component \''+e+'\': '+n)}}// By default, the default loader is the only registered component loader
/**
 *          Interpolation Parsing
 */function*In(e){const n=e.match(oo);if(n){const[e,t,i]=n.slice(1);yield*In(e),yield new po(t),yield new lo(i)}else yield new lo(e)}function*kn(e){if(e){let[n,t,i]=e.slice(1);yield new po(n),yield*In(t),yield new po(i)}}function*wn(e){for(const n of kn(e.match(ao)))n.text&&(yield n)}/**
 * These are bindings that are mapped specific attributes, such as
 * two-way communication (value/checked) or which have anti-collision
 * properties (css).
 */// The bindingContext constructor is only called directly to create the root context. For child
// contexts, use bindingContext.createChildContext or bindingContext.extend.
function On(e,n,t,o,a){// The binding context object includes static properties for the current, parent, and root view models.
// If a view model is actually stored in an observable, the corresponding binding context object, and
// any child contexts, must be updated when the view model is changed.
function s(){// Most of the time, the context will directly get a view model object, but if a function is given,
// we call the function to retrieve the view model. If the function accesses any observables or returns
// an observable, the dependency is tracked, and those observables can later cause the binding
// context to be updated.
var i=p?e():e,a=tn(i);return n?(n._subscribable&&n._subscribable(),y(l,n),l._subscribable=r):(l.$parents=[],l.$root=a,l.ko=Ct.knockoutInstance),l.$rawData=i,l.$data=a,t&&(l[t]=a),o&&o(l,n,a),l.$data}var d,r,l=this,p='function'==typeof e&&!nn(e);return a&&a.exportDependencies?void s():void(r=cn(s,null,{disposeWhen:function(){return d&&!B(d)},disposeWhenNodeIsRemoved:!0}),r.isActive()&&(l._subscribable=r,r.equalityComparer=null,d=[],r._addNode=function(e){d.push(e),j(e,function(e){i(d,e),d.length||(r.dispose(),l._subscribable=r=void 0)})}))}function An(e,n){return 2==arguments.length?void(_t(e,go,n),n._subscribable&&n._subscribable._addNode(e)):Tt(e,go)}// Retrieving binding context from arbitrary nodes
function Bn(e){// We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
switch(e.nodeType){case 1:case 8:var n=An(e);if(n)return n;if(e.parentNode)return Bn(e.parentNode);}}// Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers
function Pn(e){const n=Ct.bindingProviderInstance.bindingHandlers.get(e);return n?n.isBindingHandlerClass?n:Eo.getOrCreateFor(e,n):void 0}// Returns the valueAccesor function for a binding value
function Vn(e){return function(){return e}}// Returns the value of a valueAccessor function
function Rn(e){return e()}// Given a function that returns bindings, create and return a new object that contains
// binding value-accessors functions. Each accessor function calls the original function
// so that it always gets the latest value and all dependencies are captured. This is used
// by ko.applyBindingsToNode and getBindingsAndMakeAccessors.
function Ln(e){return x(Je(e),function(n,t){return function(){return e()[t]}})}// Given a bindings function or object, create and return a new object that contains
// binding value-accessors functions. This is used by ko.applyBindingsToNode.
function $n(e,n,t){return'function'==typeof e?Ln(e.bind(null,n,t)):x(e,Vn)}// This function is used if the binding provider doesn't include a getBindingAccessors function.
// It must be called with 'this' set to the provider instance.
function Mn(e,n){return Ln(this.getBindings.bind(this,e,n))}function Fn(e,n,t,i){var o,a=ue(n);const s=Ct.bindingProviderInstance,d=s.preprocessNode;// Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's
// possible to insert new siblings after it, and/or replace the node with a different one. This can be used to
// implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that
// trigger insertion of <template> contents at that point in the document.
if(d){for(;o=a;)a=ce(o),d.call(s,o);// Reset nextInQueue for the next loop
a=ue(n)}for(;o=a;)a=ce(o),Wn(e,o,t,i)}function jn(e){const n=Ct.bindingProviderInstance;return n.FOR_NODE_TYPES.includes(e.nodeType)&&n.nodeHasBindings(e)}function Wn(e,n,t,i){// Perf optimisation: Apply bindings only if...
// (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
//     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
// (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
var o=1===n.nodeType;o&&he(n);var a=o&&t||// Case (1)
jn(n);// Case (2)
const{shouldBindDescendants:s}=a?Hn(n,null,e,t,i):{shouldBindDescendants:!0};s&&!Co[P(n)]&&Fn(e,n,/* bindingContextsMayDifferFromDomParentElement: */!o,i)}function*Un(t){const i=[],o={},a=[];// Depth-first sort
// A temporary record of which bindings are already in 'result'
v(t,function s(d){if(!o[d]){const o=Pn(d);if(!o)return;// First add dependencies (if any) of the current binding
o.after&&(a.push(d),e(o.after,function(e){if(t[e])if(-1!==n(a,e))throw Error('Cannot combine the following bindings, because they have a cyclic dependency: '+a.join(', '));else s(e)}),a.length--),i.push([d,o])}o[d]=!0});for(const e of i)yield e}function Hn(e,n,t,i,o){// Prevent multiple applyBindings calls for the same node, except when a binding value is specified
var a=Tt(e,Do);if(!n){if(a)return Gn({during:'apply',errorCaptured:new Error('You cannot apply bindings multiple times to the same element.'),element:e,bindingContext:t}),!1;_t(e,Do,!0)}// Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
// we can easily recover it just by scanning up the node's ancestors in the DOM
// (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
!a&&i&&An(e,t);// Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings
var s;if(n&&'function'!=typeof n)s=n;else{const i=Ct.bindingProviderInstance,o=i.getBindingAccessors||Mn;if(i.FOR_NODE_TYPES.includes(e.nodeType)){// Get the binding from the provider within a computed observable so that we can update the bindings whenever
// the binding context is updated or if the binding provider accesses observables.
var d=cn(function(){return s=n?n(t,e):o.call(i,e,t),s&&t._subscribable&&t._subscribable(),s},null,{disposeWhenNodeIsRemoved:e});s&&d.isActive()||(d=null)}}var r;if(s){// Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated
function n(){return x(d?d():s,Rn)}// The following is the 3.x allBindings API
const i={};_t(e,'bindingHandlers',i);// Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding
// context update), just return the value accessor from the binding. Otherwise, return a function that always gets
// the latest binding value and registers a dependency on the binding updater.
const a=d?(e)=>function(n){var t=d()[e];return 0===arguments.length?Rn(t):t(n)}:(e)=>s[e];n.has=(e)=>e in s,n.get=(e)=>s[e]&&Rn(a(e));for(const[d,l]of Un(s)){// Go through the sorted bindings, calling init and update for each
function p(i,o){Gn({during:i,errorCaptured:o,bindings:s,allBindings:n,bindingKey:d,bindingContext:t,element:e,valueAccessor:a(d)})}if(8===e.nodeType&&!l.allowVirtualElements)throw new Error(`The binding [${d}] cannot be used with virtual elements`);try{const s=Je(()=>new l({allBindings:n,$element:e,$context:t,onError:p,valueAccessor(...e){return a(d)(...e)}}));// Expose the bindings via domData.
if(i[d]=s,s.controlsDescendants){if(void 0!=r)throw new Error('Multiple bindings ('+r+' and '+d+') are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.');r=d}s.bindingCompleted instanceof Ct.Promise&&o.add(s.bindingCompleted)}catch(e){p('creation',e)}}}return{shouldBindDescendants:void 0===r}}function Kn(e){return e&&e instanceof On?e:new On(e)}function Qn(e,n,t,i){return 1===e.nodeType&&he(e),Hn(e,n,Kn(t),!0,i)}function qn(e,n){const t=new Set;return(1===n.nodeType||8===n.nodeType)&&Fn(Kn(e),n,!0,t),Ct.Promise.all(t)}function zn(e,n){const t=new Set;// If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.
if(void 0===!Ct.jQuery&&window.jQuery&&(Ct.jQuery=window.jQuery),n&&1!==n.nodeType&&8!==n.nodeType)throw new Error('ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node');return n=n||window.document.body,Wn(Kn(e),n,!0,t),Ct.Promise.all(t)}function Gn(e){var n;e.bindingKey?(n=e.errorCaptured,e.message='Unable to process binding "'+e.bindingKey+'" in binding "'+e.bindingKey+'"\nMessage: '+(n.message?n.message:n)):n=e.errorCaptured;try{y(n,e)}catch(t){e.stack=n.stack,n=new Error(n.message?n.message:n),y(n,e)}Ct.onError(n)}/* eslint no-cond-assign: 0 */// Objective:
// * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
//   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
// * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
//   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
//   previously mapped - retain those nodes, and just insert/delete other ones
// "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
// You can use this, for example, to activate bindings on those nodes.
function Jn(e,n,t,i,o){// Map this array value inside a dependentObservable so we re-map when any dependency changes
var a=[],s=cn(function(){var s=n(t,o,Y(a,e))||[];// On subsequent evaluations, just replace the previously-inserted DOM nodes
0<a.length&&(ve(a,s),i&&Je(i,null,[t,s,o])),a.length=0,d(a,s)},null,{disposeWhenNodeIsRemoved:e,disposeWhen:function(){return!B(a)}});return{mappedNodes:a,dependentObservable:s.isActive()?s:void 0}}function Yn(n,t,o,s,d){function r(e,t){p=h[t],N!==t&&(T[e]=p),p.indexObservable(N++),Y(p.mappedNodes,n),v.push(p),C.push(p)}function l(t,o){if(t)for(var a=0,i=o.length;a<i;a++)o[a]&&e(o[a].mappedNodes,function(e){t(e,a,o[a].arrayEntry)})}t=t||[],s=s||{};// Build the new mapping result
for(var p,c,m,g=void 0===Tt(n,To),h=Tt(n,To)||[],f=a(h,function(e){return e.arrayEntry}),b=u(f,t,s.dontLimitMoves),v=[],x=0,N=0,E=[],C=[],D=[],T=[],_=[],S=0;c=b[S];S++)switch(m=c.moved,c.status){case'deleted':void 0===m&&(p=h[x],p.dependentObservable&&(p.dependentObservable.dispose(),p.dependentObservable=void 0),Y(p.mappedNodes,n).length&&(s.beforeRemove&&(v.push(p),C.push(p),p.arrayEntry===_o?p=null:D[S]=p),p&&E.push.apply(E,p.mappedNodes))),x++;break;case'retained':r(S,x++);break;case'added':void 0===m?(p={arrayEntry:c.value,indexObservable:Ze(N++)},v.push(p),C.push(p),!g&&(_[S]=p)):r(S,m);}// Store a copy of the array items we just considered so we can difference it next time
_t(n,To,v),l(s.beforeMove,T),e(E,s.beforeRemove?K:Q),S=0;for(var i,I,k=ue(n);p=C[S];S++){p.mappedNodes||y(p,Jn(n,o,p.arrayEntry,d,p.indexObservable));// Put nodes in the right place if they aren't there already
for(var w=0;I=p.mappedNodes[w];k=I.nextSibling,i=I,w++)I!==k&&pe(n,I,i);// Run the callbacks for newly added nodes (for example, to apply bindings, etc.)
!p.initialized&&d&&(d(p.arrayEntry,p.mappedNodes,p.indexObservable),p.initialized=!0)}// If there's a beforeRemove callback, call it after reordering.
// Note that we assume that the beforeRemove callback will usually be used to remove the nodes using
// some sort of animation, which is why we first reorder the nodes that will be removed. If the
// callback instead removes the nodes right away, it would be more efficient to skip reordering them.
// Perhaps we'll make that change in the future if this scenario becomes more common.
// Replace the stored values of deleted items with a dummy value. This provides two benefits: it marks this item
// as already "removed" so we won't call beforeRemove for it again, and it ensures that the item won't match up
// with an actual item in the array and appear as "retained" or "moved".
for(l(s.beforeRemove,D),S=0;S<D.length;++S)D[S]&&(D[S].arrayEntry=_o);// Finally call afterMove and afterAdd callbacks
l(s.afterMove,T),l(s.afterAdd,_)}// For certain common events (currently just 'click'), allow a simplified data-binding syntax
// e.g. click:handler instead of the usual full-length event:{click:handler}
function Xn(e){if(this.domElement=e,!!e){var n=P(e);this.templateType='script'===n?Jo:'textarea'===n?Yo:// For browsers with proper <template> element support, where the .content property gives a document fragment
'template'==n&&e.content&&11===e.content.nodeType?Xo:Zo}}function Zn(e){return Tt(e,na)||{}}function et(e,n){_t(e,na,n)}// ---- ko.templateSources.anonymousTemplate -----
// Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
// For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
// Writing to "text" is still supported, but then the template data will not be available as DOM nodes.
function nt(e){this.domElement=e}// If you want to make a custom template engine,
//
// [1] Inherit from this class (like ko.nativeTemplateEngine does)
// [2] Override 'renderTemplateSource', supplying a function with this signature:
//
//        function (templateSource, bindingContext, options) {
//            // - templateSource.text() is the text of the template you should render
//            // - bindingContext.$data is the data you should pass into the template
//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
//            //     and bindingContext.$root available in the template too
//            // - options gives you access to any other properties set on "data-bind: { template: options }"
//            // - templateDocument is the document object of the template
//            //
//            // Return value: an array of DOM nodes
//        }
//
// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
//
//        function (script) {
//            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
//        }
//
//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.
function tt(){}function it(e){if(void 0!==e&&!(e instanceof tt))// TODO: ko.templateEngine to appropriate name
throw new Error('templateEngine must inherit from ko.templateEngine');ta=e}function ot(e,n,t){for(let i,o=e,a=ce(n);o&&(i=o)!==a;)o=ce(i),t(i,o)}function at(e,n,t){// To be used on any nodes that have been rendered by a template and have been inserted into some parent element
// Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
// the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
// (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
// (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)
if(e.length){var i=e[0],o=e[e.length-1],a=i.parentNode,s=Ct.bindingProviderInstance,d=s.preprocessNode;if(d){if(ot(i,o,function(e,n){var t=e.previousSibling,a=d.call(s,e);a&&(e===i&&(i=a[0]||n),e===o&&(o=a[a.length-1]||t))}),e.length=0,!i)// preprocessNode might have removed all the nodes, in which case there's nothing left to do
return;i===o?e.push(i):(e.push(i,o),Y(e,a))}// Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
// whereas a regular applyBindings won't introduce new memoized nodes
ot(i,o,function(e){(1===e.nodeType||8===e.nodeType)&&zn(n,e).then(t)}),ot(i,o,function(e){(1===e.nodeType||8===e.nodeType)&&Pe(e,[n])}),Y(e,a)}}function st(e){return e.nodeType?e:0<e.length?e[0]:null}function dt(e,n,t,i,o,a){o=o||{};var s=e&&st(e),d=(s||t||{}).ownerDocument,r=o.templateEngine||ta,l=r.renderTemplate(t,i,o,d);// Loosely check result is an array of DOM nodes
if('number'!=typeof l.length||0<l.length&&'number'!=typeof l[0].nodeType)throw new Error('Template engine must return an array of DOM nodes');var p=!1;switch(n){case'replaceChildren':re(e,l),p=!0;break;case'replaceNode':ve(e,l),p=!0;break;case'ignoreTargetNode':break;default:throw new Error('Unknown renderMode: '+n);}return p&&(at(l,i,a),o.afterRender&&Je(o.afterRender,null,[l,i.$data])),l}function rt(e,n,t){// The template can be specified as:
return nn(e)?e():'function'==typeof e?e(n,t):e}function lt(e,n,t,i,o,a){if(t=t||{},void 0===(t.templateEngine||ta))throw new Error('Set a template engine before calling renderTemplate');if(o=o||'replaceChildren',i){var s=st(i),d=function(){return!s||!A(s)},r=s&&'replaceNode'===o?s.parentNode:s;// Passive disposal (on next evaluation)
return cn(// So the DOM is automatically updated when any dependency changes
function(){// Ensure we've got a proper binding context to work with
var d=n&&n instanceof On?n:new On(n,null,null,null,{exportDependencies:!0}),r=rt(e,d.$data,d);const l=dt(i,o,r,d,t,a);'replaceNode'===o&&(i=l,s=st(i))},null,{disposeWhen:d,disposeWhenNodeIsRemoved:r})}// We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
return Ae(function(i){lt(e,n,t,i,'replaceNode')})}function pt(e,n,t,i,o,a){// This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
function d(n,i){r=o.createChildContext(n,t.as,function(e){e.$index=i});var s=rt(e,n,r);return dt(null,'ignoreTargetNode',s,r,t,a)}// This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
// Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
// activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
var r,l=function(e,n/*, index */){at(n,r,a),t.afterRender&&t.afterRender(n,e),r=null};return cn(function(){var e=tn(n)||[];'number'!=typeof e.length&&(e=[e]);// Filter out any entries marked as destroyed
var o=s(e,function(e){return t.includeDestroyed||void 0===e||null===e||!tn(e._destroy)});// Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
// If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.
Je(Yn,null,[i,o,d,t,l])},null,{disposeWhenNodeIsRemoved:i})}function ut(){}/**
 * Test a node for whether it represents an "else" condition.
 * @param  {HTMLElement}  node to be tested
 * @return {Boolean}      true when
 *
 * Matches <!-- else -->
 */function ct(e){return 8===e.nodeType&&'else'===e.nodeValue.trim().toLowerCase()}function mt(e){for(var n=se(e),t=0,i=n.length;t<i;++t)if(ct(n[t]))return!0;return!1}/**
 * Clone the nodes, returning `ifNodes`, `elseNodes`
 * @param  {HTMLElement} element The nodes to be cloned
 * @param  {boolean}    hasElse short-circuit to speed up the inner-loop.
 * @return {object}         Containing the cloned nodes.
 */function gt(e,n){const t=se(e),o=[],a=[];let s=o;for(var d=0,i=t.length;d<i;++d)n&&ct(t[d])?(s=a,n=!1):s.push(K(t[d].cloneNode(!0)));return{ifNodes:o,elseNodes:a}}/**
 * Create a DOMbinding that controls DOM nodes presence
 *
 * Covers e.g.
 *
 * 1. DOM Nodes contents
 *
 * <div data-bind='if: x'>
 * <!-- else --> ... an optional "if"
 * </div>
 *
 * 2. Virtual elements
 *
 * <!-- ko if: x -->
 * <!-- else -->
 * <!-- /ko -->
 *
 * 3. Else binding
 * <div data-bind='if: x'></div>
 * <div data-bind='else'></div>
 */// from https://github.com/jonschlinkert/is-plain-object
function ht(e){return!!e&&'object'==typeof e&&e.constructor===Object}// Get a copy of the (possibly virtual) child nodes of the given element,
// put them into a container, then empty the given node.
function ft(n){var t,i=document.createElement('div');return n.content?t=n.content:'SCRIPT'===n.tagName?(t=document.createElement('div'),t.innerHTML=n.text):t=n,e(se(t),function(e){e&&i.insertBefore(e.cloneNode(!0),null)}),i}// Mimic a KO change item 'add'
function bt(e,n){return{status:'added',value:e,index:n}}// store a symbol for caching the pending delete info index in the data item objects
// Extend the given context with a $index (passed in via the createChildContext)
function yt(e,n){e&&(n.$index=Ze()),n.$list=this.data}var vt=Math.max,xt=Math.min,Nt='added',Et='deleted',Ct={deferUpdates:!1,useOnlyNativeEvents:!1,protoProperty:'__ko_proto__',// Modify the default attribute from `data-bind`.
defaultBindingAttribute:'data-bind',// Enable/disable <!-- ko binding: ... -> style bindings
allowVirtualElements:!0,// Global variables that can be accessed from bindings.
bindingGlobals:window,// An instance of the binding provider.
bindingProviderInstance:null,// jQuery will be automatically set to window.jQuery in applyBindings
// if it is (strictly equal to) undefined.  Set it to false or null to
// disable automatically setting jQuery.
jQuery:window&&window.jQuery,Promise:window&&window.Promise,taskScheduler:null,debug:!1,// Filters for bindings
//   data-bind="expression | filter_1 | filter_2"
filters:{},onError:function(n){throw n},set:function(e,n){Ct[e]=n}};Object.defineProperty(Ct,'$',{get:function(){return Ct.jQuery}});var Dt,Tt,_t,St,It=document&&function(){// Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
for(var e=3,n=document.createElement('div'),t=n.getElementsByTagName('i');n.innerHTML='<!--[if gt IE '+ ++e+']><i></i><![endif]-->',t[0];);return 4<e?e:void 0}(),kt=Ct.protoProperty,wt={__proto__:[]}instanceof Array,Ot=wt?C:y,At='function'==typeof Symbol,Bt=/\S+/g,Pt=window&&window.jQuery,Vt='__ko__data'+new Date,Rt=0;'WeakMap'in window?(Dt=new WeakMap,Tt=function(e,n){return(Dt.get(e)||{})[n]},_t=function(e,n,t){var i;Dt.has(e)?i=Dt.get(e):(i={},Dt.set(e,i)),i[n]=t},St=function(e){return Dt.delete(e)}):(Dt={},Tt=function(e,n){var t=L(e,!1);return void 0===t?void 0:t[n]},_t=function(e,n,t){if(void 0!==t||void 0!==L(e,!1)){var i=L(e,!0);i[n]=t}},St=function(e){var n=e[Vt];return!!n&&(delete Dt[n],e[Vt]=null,!0)});var Lt=Object.freeze({nextKey:$,get get(){return Tt},get set(){return _t},get clear(){return St}}),$t=$(),Mt={1:!0,8:!0,9:!0},Ft={1:!0,9:!0},jt=[];//
// DOM node disposal
//
/* eslint no-cond-assign: 0 */// Node types:
// 1: Element
// 8: Comment
// 9: Document
jt.push(q);//
// DOM Events
//
// Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
var Wt={},Ut={},Ht=navigator&&/Firefox\/2/i.test(navigator.userAgent)?'KeyboardEvent':'UIEvents';Wt[Ht]=['keyup','keydown','keypress'],Wt.MouseEvents=['click','dblclick','mousedown','mouseup','mousemove','mouseover','mouseout','mouseenter','mouseleave'],v(Wt,function(e,n){if(n.length)for(var t=0,i=n.length;t<i;t++)Ut[n[t]]=e});var Kt={propertychange:!0},Qt=document&&'<!--test-->'===document.createComment('test').text,qt=Qt?/^<!--\s*ko(?:\s+([\s\S]+))?\s*-->$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,zt=Qt?/^<!--\s*\/ko\s*-->$/:/^\s*\/ko\s*$/,Gt={ul:!0,ol:!0},Jt={},Yt=Object.freeze({startCommentRegex:qt,endCommentRegex:zt,isStartComment:ne,isEndComment:te,getVirtualChildren:ie,allowedBindings:Jt,hasBindingValue:ne,childNodes:se,emptyNode:de,setDomNodeChildren:re,prepend:le,insertAfter:pe,firstChild:ue,lastChild:function(e){var n,t=ue(e);do n=t;while(t=ce(t));return n},nextSibling:ce,previousSibling:me,virtualNodeBindingValue:ge,normaliseVirtualElementDomStructure:he}),Xt=[0,'',''],Zt=[1,'<table>','</table>'],ei=[3,'<table><tbody><tr>','</tr></tbody></table>'],ni=[1,'<select multiple=\'multiple\'>','</select>'],ti={area:[1,'<map>','</map>'],col:[2,'<table><tbody></tbody><colgroup>','</colgroup></table>'],colgroup:Zt,caption:Zt,legend:[1,'<fieldset>','</fieldset>'],thead:Zt,tbody:Zt,tfoot:Zt,tr:[2,'<table><tbody>','</tbody></table>'],td:ei,th:ei,option:ni,optgroup:ni,param:[1,'<object>','</object>']},ii='content'in document.createElement('template'),oi={},ai=Object.freeze({memoize:Ae,unmemoize:Be,unmemoizeDomNodeAndDescendants:Pe,parseMemoText:Ve}),si=[],di=0,ri=1,li=0;//
//  Tasks Micro-scheduler
//  ===
//
/* eslint no-cond-assign: 0 */Ct.taskScheduler=window.MutationObserver&&!(window.navigator&&window.navigator.standalone)?function(e){var n=document.createElement('div');return new MutationObserver(e).observe(n,{attributes:!0}),function(){n.classList.toggle('foo')}}(Le):document&&'onreadystatechange'in document.createElement('script')?function(e){var n=document.createElement('script');n.onreadystatechange=function(){n.onreadystatechange=null,document.documentElement.removeChild(n),n=null,e()},document.documentElement.appendChild(n)}:function(e){setTimeout(e,0)};var pi=Object.freeze({schedule:Me,cancel:Fe,resetForTesting:function(){var e=di-li;return li=di=si.length=0,e},runEarly:Re}),ui=Object.freeze({tasks:pi,virtualElements:Yt,domData:Lt,memoization:ai,jQuerySetInstance:function(e){Pt=e},options:Ct,arrayForEach:e,arrayIndexOf:n,arrayFirst:t,arrayRemoveItem:i,arrayGetDistinctValues:o,arrayMap:a,arrayFilter:s,arrayPushAll:d,addOrRemoveItem:r,makeArray:l,range:function(e,n){e='function'==typeof e?e():e,n='function'==typeof n?n():n;for(var t=[],o=e;o<=n;o++)t.push(o);return t},findMovesInArrayComparison:p,compareArrays:u,throttle:f,debounce:b,catchFunctionErrors:m,deferError:g,safeSetTimeout:h,ieVersion:It,isIe6:6===It,isIe7:7===It,extend:y,objectForEach:v,objectMap:x,getObjectOwnProperty:N,clonePlainObjectDeep:E,canSetPrototype:wt,setPrototypeOf:C,setPrototypeOfOrExtend:Ot,hasPrototype:D,stringTrim:T,stringStartsWith:_,parseJson:function(e){return'string'==typeof e&&(e=T(e),e)?JSON&&JSON.parse?JSON.parse(e):new Function('return '+e)():null},stringifyJson:S,useSymbols:At,createSymbolOrString:I,toggleDomNodeCssClass:k,registerEventHandler:G,triggerEvent:J,domNodeIsContainedBy:O,domNodeIsAttachedToDocument:A,anyDomNodeIsAttachedToDocument:B,tagNameLower:P,isDomElement:V,isDocumentFragment:R,moveCleanedNodesToContainerElement:fe,cloneNodes:be,setDomNodeChildren:ye,replaceDomNodes:ve,setElementName:xe,setTextContent:Ne,emptyDomNode:Ee,fixUpContinuousNodeArray:Y,setOptionNodeSelectionState:X,forceRefresh:Z,ensureSelectElementIsRenderedCorrectly:ee,parseHtmlFragment:Se,setHtml:Ie,addDisposeCallback:j,removeDisposeCallback:H,cleanNode:K,removeNode:Q,otherNodeCleanerFunctions:jt,cleanjQueryData:q}),ci={undefined:1,boolean:1,number:1,string:1},mi={notify:function(e,n){e.equalityComparer='always'==n?null:// null equalityComparer means to always notify
We},deferred:function(e,n){if(!0!==n)throw new Error('The \'deferred\' extender only accepts the value \'true\', because it is not supported to turn deferral off once enabled.');je(e)},rateLimit:function(e,n){var t,i,o;'number'==typeof n?t=n:(t=n.timeout,i=n.method),e._deferUpdates=!1,o='notifyWhenChangesStop'==i?b:f,e.limit(function(e){return o(e,t)})}};/*
  tko.util
  ===


*/// Sub-Modules;
Ue.prototype.dispose=function(){this.isDisposed=!0,this.disposeCallback()};var gi='change',hi={init(e){e._subscriptions={},e._versionNumber=1},subscribe(e,n,t){var o=this;t=t||gi;var a=n?e.bind(n):e,s=new Ue(o,a,function(){i(o._subscriptions[t],s),o.afterSubscriptionRemove&&o.afterSubscriptionRemove(t)});return o.beforeSubscriptionAdd&&o.beforeSubscriptionAdd(t),o._subscriptions[t]||(o._subscriptions[t]=[]),o._subscriptions[t].push(s),s},notifySubscribers(e,n){if(n=n||gi,n===gi&&this.updateVersion(),this.hasSubscriptionsForEvent(n))try{qe();// Begin suppressing dependency detection (by setting the top frame to undefined)
for(var t,o=this._subscriptions[n].slice(0),a=0;t=o[a];++a)// In case a subscription was disposed during the arrayForEach cycle, check
// for isDisposed on each subscription before invoking its callback
t.isDisposed||t.callback(e)}finally{ze()}},getVersion(){return this._versionNumber},hasChanged(e){return this.getVersion()!==e},updateVersion(){++this._versionNumber},hasSubscriptionsForEvent(e){return this._subscriptions[e]&&this._subscriptions[e].length},getSubscriptionsCount(e){if(e)return this._subscriptions[e]&&this._subscriptions[e].length||0;var n=0;return v(this._subscriptions,function(e,t){'dirty'!==e&&(n+=t.length)}),n},isDifferent(e,n){return!this.equalityComparer||!this.equalityComparer(e,n)},once(e){const n=this.subscribe((t)=>{n.dispose(),e(t)})},when(e,n){const t=this.peek(),i=1<arguments.length,o='function'==typeof e?e:(n)=>n===e;return o(t)?Ct.Promise.resolve(i?n:t):new Ct.Promise((e)=>{const t=this.subscribe((a)=>{o(a)&&(t.dispose(),e(i?n:a))})})},yet(e,...n){const t='function'==typeof e?e:(n)=>n===e;return this.when((e)=>!t(e),...n)},next(){return new Promise((e)=>this.once(e))},extend:function(e){var n=this;return e&&v(e,function(e,t){var i=mi[e];'function'==typeof i?n=i(n,t)||n:Ct.onError(new Error('Extender not found: '+e))}),n}};wt&&C(hi,Function.prototype),He.fn=hi;const fi=[];let bi,yi=0;var vi=Object.freeze({begin:qe,end:ze,registerDependency:Ge,ignore:Je,getDependenciesCount:Ye,isInitial:Xe,ignoreDependencies:Je}),xi=I('_latestValue');//
//  Observable values
//  ---
//
Ze.fn={equalityComparer:We,peek(){return this[xi]},valueHasMutated(){this.notifySubscribers(this[xi])},valueWillMutate(){this.notifySubscribers(this[xi],'beforeChange')},then(e,n){try{e(this())}catch(t){n(t)}}},He.fn.limit=function(e){var n,t,i,o=this,a=nn(o);o._origNotifySubscribers||(o._origNotifySubscribers=o.notifySubscribers,o.notifySubscribers=en);var s=e(function(){o._notificationIsPending=!1,a&&i===o&&(i=o()),n=!1,o.isDifferent(t,i)&&o._origNotifySubscribers(t=i)});o._limitChange=function(e){o._notificationIsPending=n=!0,i=e,s()},o._limitBeforeChange=function(e){n||(t=e,o._origNotifySubscribers(e,'beforeChange'))}},wt&&C(Ze.fn,He.fn);var Ni=Ze.protoProperty=Ct.protoProperty;Ze.fn[Ni]=Ze;var Ei='arrayChange';sn.compareArrays=u,mi.trackArrayChanges=sn,dn.fn={remove:function(e){for(var n,t=this.peek(),o=[],a='function'!=typeof e||nn(e)?function(n){return n===e}:e,s=0;s<t.length;s++)n=t[s],a(n)&&(0===o.length&&this.valueWillMutate(),o.push(n),t.splice(s,1),s--);return o.length&&this.valueHasMutated(),o},removeAll:function(e){// If you passed zero args, we remove everything
if(void 0===e){var t=this.peek(),i=t.slice(0);return this.valueWillMutate(),t.splice(0,t.length),this.valueHasMutated(),i}// If you passed an arg, we interpret it as an array of entries to remove
return e?this.remove(function(t){return 0<=n(e,t)}):[]},destroy:function(e){var n=this.peek(),t='function'!=typeof e||nn(e)?function(n){return n===e}:e;this.valueWillMutate();for(var o,a=n.length-1;0<=a;a--)o=n[a],t(o)&&(n[a]._destroy=!0);this.valueHasMutated()},destroyAll:function(e){// If you passed zero args, we destroy everything
return void 0===e?this.destroy(function(){return!0}):e?this.destroy(function(t){return 0<=n(e,t)}):[];// If you passed an arg, we interpret it as an array of entries to destroy
},indexOf:function(e){var t=this();return n(t,e)},replace:function(e,n){var t=this.indexOf(e);0<=t&&(this.valueWillMutate(),this.peek()[t]=n,this.valueHasMutated())}},wt&&C(dn.fn,Ze.fn),e(['pop','push','reverse','shift','sort','splice','unshift'],function(e){dn.fn[e]=function(){// Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
// (for consistency with mutating regular observables)
var n=this.peek();this.valueWillMutate(),this.cacheDiffForKnownOperation(n,e,arguments);var t=n[e].apply(n,arguments);// The native sort and reverse methods return a reference to the array, but it makes more sense to return the observable array instead.
return this.valueHasMutated(),t===n?this:t}}),e(['slice'],function(e){dn.fn[e]=function(){var n=this();return n[e].apply(n,arguments)}});//
// Helpers
// ---
// toJS & toJSON
//
var Ci=10;un.prototype={constructor:un,save:function(e,t){var i=n(this.keys,e);0<=i?this.values[i]=t:(this.keys.push(e),this.values.push(t))},get:function(e){var t=n(this.keys,e);return 0<=t?this.values[t]:void 0}};//
// Observables.
// ---
//
// The following are added to the root `[t]ko` object.
//
//
// Computed Observable Values
//
// (before tko, `computed` was also known as `dependentObservable`)
//
var Di=I('_state');cn.fn={equalityComparer:We,getDependenciesCount:function(){return this[Di].dependenciesCount},addDependencyTracking:function(e,n,t){if(this[Di].pure&&n===this)throw Error('A \'pure\' computed must not be called recursively');this[Di].dependencyTracking[e]=t,t._order=this[Di].dependenciesCount++,t._version=n.getVersion()},haveDependenciesChanged:function(){var e,n,t=this[Di].dependencyTracking;for(e in t)if(t.hasOwnProperty(e)&&(n=t[e],n._target.hasChanged(n._version)))return!0},markDirty:function(){this._evalDelayed&&!this[Di].isBeingEvaluated&&this._evalDelayed()},isActive:function(){return this[Di].isStale||0<this[Di].dependenciesCount},respondToChange:function(){this._notificationIsPending||this.evaluatePossiblyAsync()},subscribeToDependency:function(e){if(e._deferUpdates&&!this[Di].disposeWhenNodeIsRemoved){var n=e.subscribe(this.markDirty,this,'dirty'),t=e.subscribe(this.respondToChange,this);return{_target:e,dispose:function(){n.dispose(),t.dispose()}}}return e.subscribe(this.evaluatePossiblyAsync,this)},evaluatePossiblyAsync:function(){var e=this,n=e.throttleEvaluation;n&&0<=n?(clearTimeout(this[Di].evaluationTimeoutInstance),this[Di].evaluationTimeoutInstance=h(function(){e.evaluateImmediate(!0)},n)):e._evalDelayed?e._evalDelayed():e.evaluateImmediate(!0)},evaluateImmediate:function(e){var n=this,t=n[Di],i=t.disposeWhen;if(!t.isBeingEvaluated&&!t.isDisposed){if(!(t.disposeWhenNodeIsRemoved&&!A(t.disposeWhenNodeIsRemoved)||i&&i()))t.suppressDisposalUntilDisposeWhenReturnsFalse=!1;else// See comment above about suppressDisposalUntilDisposeWhenReturnsFalse
if(!t.suppressDisposalUntilDisposeWhenReturnsFalse)return void n.dispose();t.isBeingEvaluated=!0;try{this.evaluateImmediate_CallReadWithDependencyDetection(e)}finally{t.isBeingEvaluated=!1}t.dependenciesCount||n.dispose()}// Do not evaluate (and possibly capture new dependencies) if disposed
},evaluateImmediate_CallReadWithDependencyDetection:function(e){// This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.
// Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,
// which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).
var n=this,t=n[Di],i=t.pure?void 0:!t.dependenciesCount,// If we're evaluating when there are no previous dependencies, it must be the first time
o={computedObservable:n,disposalCandidates:t.dependencyTracking,disposalCount:t.dependenciesCount};// Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
// Then, during evaluation, we cross off any that are in fact still being used.
qe({callbackTarget:o,callback:gn,computed:n,isInitial:i}),t.dependencyTracking={},t.dependenciesCount=0;var a=this.evaluateImmediate_CallReadThenEndDependencyDetection(t,o);n.isDifferent(t.latestValue,a)&&(!t.isSleeping&&n.notifySubscribers(t.latestValue,'beforeChange'),t.latestValue=a,t.isSleeping?n.updateVersion():e&&n.notifySubscribers(t.latestValue)),i&&n.notifySubscribers(t.latestValue,'awake')},evaluateImmediate_CallReadThenEndDependencyDetection:function(e,n){// This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.
// You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection
// can be independent of try/finally blocks, which contributes to saving about 40% off the CPU
// overhead of computed evaluation (on V8 at least).
try{var t=e.readFunction;return e.evaluatorFunctionTarget?t.call(e.evaluatorFunctionTarget):t()}finally{ze(),n.disposalCount&&!e.isSleeping&&v(n.disposalCandidates,mn),e.isStale=!1}},peek:function(){// Peek won't re-evaluate, except while the computed is sleeping or to get the initial value when "deferEvaluation" is set.
var e=this[Di];return(e.isStale&&!e.dependenciesCount||e.isSleeping&&this.haveDependenciesChanged())&&this.evaluateImmediate(),e.latestValue},limit:function(e){He.fn.limit.call(this,e),this._evalDelayed=function(){this._limitBeforeChange(this[Di].latestValue),this[Di].isStale=!0,this._limitChange(this)}},dispose:function(){var e=this[Di];!e.isSleeping&&e.dependencyTracking&&v(e.dependencyTracking,function(e,n){n.dispose&&n.dispose()}),e.disposeWhenNodeIsRemoved&&e.domNodeDisposalCallback&&H(e.disposeWhenNodeIsRemoved,e.domNodeDisposalCallback),e.dependencyTracking=null,e.dependenciesCount=0,e.isDisposed=!0,e.isStale=!1,e.isSleeping=!1,e.disposeWhenNodeIsRemoved=null,e.readFunction=null,Ct.debug&&(this._options=null)}};var Ti={beforeSubscriptionAdd:function(n){// If asleep, wake up the computed by subscribing to any dependencies.
var t=this,i=t[Di];if(!i.isDisposed&&i.isSleeping&&'change'==n){if(i.isSleeping=!1,i.isStale||t.haveDependenciesChanged())i.dependencyTracking=null,i.dependenciesCount=0,i.isStale=!0,t.evaluateImmediate();else{// First put the dependencies in order
var o=[];v(i.dependencyTracking,function(e,n){o[n._order]=e}),e(o,function(e,n){var o=i.dependencyTracking[e],a=t.subscribeToDependency(o._target);a._order=n,a._version=o._version,i.dependencyTracking[e]=a})}i.isDisposed||t.notifySubscribers(i.latestValue,'awake')}},afterSubscriptionRemove:function(e){var n=this[Di];n.isDisposed||'change'!=e||this.hasSubscriptionsForEvent('change')||(v(n.dependencyTracking,function(e,t){t.dispose&&(n.dependencyTracking[e]={_target:t._target,_order:t._order,_version:t._version},t.dispose())}),n.isSleeping=!0,this.notifySubscribers(void 0,'asleep'))},getVersion:function(){// Because a pure computed is not automatically updated while it is sleeping, we can't
// simply return the version number. Instead, we check if any of the dependencies have
// changed and conditionally re-evaluate the computed observable.
var e=this[Di];return e.isSleeping&&(e.isStale||this.haveDependenciesChanged())&&this.evaluateImmediate(),He.fn.getVersion.call(this)}},_i={beforeSubscriptionAdd:function(e){('change'==e||'beforeChange'==e)&&this.peek()}};wt&&C(cn.fn,He.fn);// Set the proto chain values for ko.hasPrototype
var Si=Ze.protoProperty;// == "__ko_proto__"
cn[Si]=Ze,cn.fn[Si]=cn,mi.throttle=function(e,n){e.throttleEvaluation=n;// (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
//     so the target cannot change value synchronously or faster than a certain rate
var t=null;return cn({read:e,write:function(i){clearTimeout(t),t=setTimeout(function(){e(i)},n)}})};const Ii={// unary
"@":function(e,n){for(;'function'==typeof n;)n=n();return n},"#":(e,n)=>()=>tn(n),// Convert to read-only.
"=>":fn,"!":function(e,n){return!n},"!!":function(e,n){return!!n},"++":function(e,n){return++n},"--":function(e,n){return--n},// mul/div
"*":function(e,n){return e*n},"/":function(e,n){return e/n},"%":function(e,n){return e%n},// sub/add
"+":function(e,n){return e+n},"-":function(e,n){return(e||0)-(n||0)},"&-":function(e,n){return-1*n},// relational
"<":function(e,n){return e<n},"<=":function(e,n){return e<=n},">":function(e,n){return e>n},">=":function(e,n){return e>=n},//    TODO: 'in': function (a, b) { return a in b; },
//    TODO: 'instanceof': function (a, b) { return a instanceof b; },
// equality
"==":function(e,n){return e===n},"!=":function(e,n){return e!==n},"===":function(e,n){return e===n},"!==":function(e,n){return e!==n},// bitwise
"&":function(e,n){return e&n},"^":function(e,n){return e^n},"|":function(e,n){return e|n},// logic
"&&":function(e,n){return e&&n},"||":function(e,n){return e||n},// Access
".":function(e,n){return e[n]},"[":function(e,n){return e[n]},// conditional/ternary
// '?': ternary See Node.js
// Function-Call
call:function(e,n){return e.apply(null,n)}};/* Order of precedence from:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table
*/// Our operator - unwrap/call
Ii['@'].precedence=21,Ii['#'].precedence=21,Ii['=>'].precedence=20,Ii['.'].precedence=19,Ii['['].precedence=19,Ii['!'].precedence=16,Ii['!!'].precedence=16,Ii['++'].precedence=16,Ii['--'].precedence=16,Ii['&-'].precedence=16,Ii['%'].precedence=14,Ii['*'].precedence=14,Ii['/'].precedence=14,Ii['+'].precedence=13,Ii['-'].precedence=13,Ii['|'].precedence=12,Ii['^'].precedence=11,Ii['&'].precedence=10,Ii['<'].precedence=11,Ii['<='].precedence=11,Ii['>'].precedence=11,Ii['>='].precedence=11,Ii['=='].precedence=10,Ii['!='].precedence=10,Ii['==='].precedence=10,Ii['!=='].precedence=10,Ii['&&'].precedence=6,Ii['||'].precedence=5,Ii['&&'].earlyOut=(e)=>!e,Ii['||'].earlyOut=(e)=>e,Ii.call.precedence=1;const ki=Symbol('Node - Is Expression Or Identifier');class wi{constructor(e,n,t){this.lhs=e,this.op=n,this.rhs=t}static get operators(){return Ii}get_leaf_value(e,n,t,i){// Identifiers and Expressions
return'function'==typeof e?tn(e()):'object'!=typeof e||null===e?e:e[wi.isExpressionOrIdentifierSymbol]?tn(e.get_value(void 0,n,t,i)):e;// primitives
// Plain object/class.
}/**
   * Return a function that calculates and returns an expression's value
   * when called.
   * @param  {array} ops  The operations to perform
   * @return {function}   The function that calculates the expression.
   *
   * Note that for a lambda, we do not evaluate the RHS expression until
   * the lambda is called.
   */get_value(e,n,t,i){var i=this;if(i.op===fn)return()=>i.get_leaf_value(i.rhs,n,t,i);const o=i.get_leaf_value(i.lhs,n,t,i),a=i.op.earlyOut;if(a&&a(o))return o;const s=i.get_leaf_value(i.rhs,n,t,i);return i.op(o,s,n,t)}//
// Class variables.
//
static get isExpressionOrIdentifierSymbol(){return ki}get[ki](){return!0}static value_of(e,n,t,i){return e&&e[wi.isExpressionOrIdentifierSymbol]?e.get_value(e,n,t,i):e}/**
  *  Convert an array of nodes to an executable tree.
  *  @return {object} An object with a `lhs`, `rhs` and `op` key, corresponding
  *                      to the left hand side, right hand side, and
  *                      operation function.
  */static create_root(e){var n,t,i,o;// Prime the leaf = root node.
for(t=n=new wi(e.shift(),e.shift(),e.shift());i=e.shift(),o=e.shift(),!!i;)i.precedence<n.op.precedence?(n=new wi(n,i,o),t=n):(t.rhs=new wi(t.rhs,i,o),t=t.rhs);// console.log('tree', root)
return n}}/**
 * Because of cyclical dependencies on operators <-> Node <-> value_of,
 * we need to patch this in here.
 */Ii['?']=function(e,n,t,i,o){return wi.value_of(e?n.yes:n.no,t,i,o)},Ii['?'].precedence=4;class Oi{constructor(e){this.nodes=e,this.root=wi.create_root(e)}/**
   * Return the value of `this` Expression instance.
   */get_value(e,n,t,i){return this.root||(this.root=wi.create_root(this.nodes)),this.root.get_value(e,n,t,i)}}Oi.prototype[wi.isExpressionOrIdentifierSymbol]=!0;class Ai{constructor(e,n){this.parser=e,this.args=n}get_value(e,n,t,o){for(var a=[],s=0,i=this.args.length;s<i;++s)a.push(wi.value_of(this.args[s],n,t,o));return a}get[wi.isExpressionOrIdentifierSymbol](){return!0}}/**
 * The following regular expressions were generated by
 *  https://mathiasbynens.be/demo/javascript-identifier-regex
 */var Bi=/[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,Pi=/[\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;class Vi{constructor(e,n,t){this.token=n,this.dereferences=t,this.parser=e}/**
   * Apply all () and [] functions on the identifier to the lhs value e.g.
   * a()[3] has deref functions that are essentially this:
   *     [_deref_call, _deref_this where this=3]
   *
   * @param  {mixed} value  Should be an object.
   * @return {mixed}        The dereferenced value.
   *
   * [1] We want to bind any function that is a method of an object, but not
   *     corrupt any values (e.g. computed()s).   e.g. Running x.bind(obj) where
   *     we're given `data-bind='binding: obj.x'` and x is a computed will
   *     break the computed's `this` and it will stop working as expected.
   *
   *     The test `!last_value.hasOwnProperty(member)`
   *     distinguishes between functions on the prototype chain (prototypal
   *     members) and value-members added directly to the object.  This may
   *     not be the canonical test for this relationship, but it succeeds
   *     in the known test cases.
   *
   *     See: `this` tests of our dereference function.
   */dereference(e,t,o,a){let s,d=this.dereferences||[];const r=t.$data||{};let l,p,i;// becomes `this` in function calls to object properties.
for(p=0,i=d.length;p<i;++p)s=wi.value_of(d[p],t,o,a),'function'==typeof e&&d[p]instanceof Ai?(e=e.apply(l||r,s),l=e):(l=e,e=wi.value_of(e[s],t,o,a));// [1] See note above.
return'function'==typeof e&&0<i&&l!==e&&!l.hasOwnProperty(s)?e.bind(l):e}/**
   * Return the value as one would get it from the top-level i.e.
   * $data.token/$context.token/globals.token; this does not return intermediate
   * values on a chain of members i.e. $data.hello.there -- requesting the
   * Identifier('there').value will return $data/$context/globals.there.
   *
   * This will dereference using () or [arg] member.
   * @param  {object | Identifier | Expression} parent
   * @return {mixed}  Return the primitive or an accessor.
   */get_value(e,n,t,i){const o=e&&!(e instanceof Vi)?wi.value_of(e,n,t,i)[this.token]:n.lookup(this.token,t,i);return this.dereference(o,n,t,i)}assign(e,n,t){an(e[n])?e[n](t):!nn(e[n])&&(e[n]=t)}/**
   * Set the value of the Identifier.
   *
   * @param {Mixed} new_value The value that Identifier is to be set to.
   */set_value(e,t,o){const a=t.$data||{},s=this.dereferences||[];let d,i,n,r=this.token;if(Object.hasOwnProperty.call(a,r))n=a;else if(Object.hasOwnProperty.call(t,r))n=t;else if(Object.hasOwnProperty.call(o,r))n=o;else throw new Error('Identifier::set_value -- The property \''+r+'\' does not exist on the $data, $context, or globals.');// Degenerate case. {$data|$context|global}[leaf] = something;
if(i=s.length,0===i)return void this.assign(n,r,e);// First dereference is {$data|$context|global}[token].
// We cannot use this.dereference because that gives the leaf; to evoke
// the ES5 setter we have to call `obj[leaf] = new_value`
for(n=n[r],d=0;d<i-1;++d)r=s[d],n=r instanceof Ai?n():n[wi.value_of(r)];// We indicate that a dereference is a function when it is `true`.
if(!0===s[d])throw new Error('Cannot assign a value to a function.');// Call the setter for the leaf.
s[d]&&this.assign(n,wi.value_of(s[d]),e)}/**
   * Determine if a character is a valid item in an identifier.
   * Note that we do not check whether the first item is a number, nor do we
   * support unicode identifiers here.
   *
   * From:  http://stackoverflow.com/a/9337047
   * @param  {String}  ch  The character
   * @return {Boolean}     True if this is a valid identifier
   */// function is_identifier_char(ch) {
//   return (ch >= 'A' && ch <= 'Z') ||
//          (ch >= 'a' && ch <= 'z') ||
//          (ch >= '0' && ch <= 9) ||
//           ch === '_' || ch === '$';
// }
static is_valid_start_char(e){return Bi.test(e)}static is_valid_continue_char(e){return Pi.test(e)}get[wi.isExpressionOrIdentifierSymbol](){return!0}}class Ri{constructor(e,n){Object.assign(this,{yes:e,no:n})}get_value(){return this}get[wi.isExpressionOrIdentifierSymbol](){return!0}}/**
 * Originally based on (public domain):
 * https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js
 */const Li={"'":'\'','"':'"',"`":'`',"\\":'\\',"/":'/',$:'$',b:'\b',f:'\f',n:'\n',r:'\r',t:'\t'};/**
 * Construct a new Parser instance with new Parser(node, context)
 * @param {Node} node    The DOM element from which we parsed the
 *                         content.
 * @param {object} context The Knockout context.
 * @param {object} globals An object containing any desired globals.
 */class $i{white(){for(var e=this.ch;e&&' '>=e;)e=this.next();return this.comment(e)}/**
 * Slurp any C or C++ style comments
 */comment(e){if('/'!==e)return e;var n=this.at,t=this.lookahead();if('/'===t){for(;e&&(e=this.next(),'\n'!==e&&'\r'!==e););e=this.next()}else if('*'===t){for(;e;)if(e=this.next(),'*'===e&&'/'===this.lookahead()){this.next();break}return e||this.error('Unclosed comment, starting at character '+n),this.next(),this.white()}return e}next(e){return e&&e!==this.ch&&this.error('Expected \''+e+'\' but got \''+this.ch+'\''),this.ch=this.text.charAt(this.at),this.at+=1,this.ch}lookahead(){return this.text[this.at]}error(e){if(e instanceof Error)throw e;let[n,t]=e.name?[e.name,e.message]:[e,''];const i=`\n${n} ${t} of
    ${this.text}\n`+Array(this.at).join(' ')+'_/ \uD83D\uDD25 \\_\n';throw new Error(i)}name(){// A name of a binding
var e,n='';this.white();var t=this.ch;for(('\''===t||'"'===t)&&(e=t,t=this.next());t;){if(e&&t===e)return this.white(),t=this.next(),':'!==t&&','!==t&&this.error('Object name: '+n+' missing closing '+e),n;if(':'===t||' '>=t||','===t||'|'===t)return n;n+=t,t=this.next()}return n}number(){let e,n='',t=this.ch;for('-'===t&&(n='-',t=this.next('-'));'0'<=t&&'9'>=t;)n+=t,t=this.next();if('.'===t)for(n+='.',t=this.next();t&&'0'<=t&&'9'>=t;)n+=t,t=this.next();if('e'===t||'E'===t)for(n+=t,t=this.next(),('-'===t||'+'===t)&&(n+=t,t=this.next());'0'<=t&&'9'>=t;)n+=t,t=this.next();return e=+n,isFinite(e)?e:void Ct.onError(new Error('Bad number: '+e+' in '+n))}/**
 * Add a property to 'object' that equals the given value.
 * @param  {Object} object The object to add the value to.
 * @param  {String} key    object[key] is set to the given value.
 * @param  {mixed}  value  The value, may be a primitive or a function. If a
 *                         function it is unwrapped as a property.
 */objectAddValue(e,n,t){t&&t[wi.isExpressionOrIdentifierSymbol]?Object.defineProperty(e,n,{get:()=>wi.value_of(t,...this.currentContextGlobals),enumerable:!0}):Array.isArray(t)?Object.defineProperty(e,n,{get:()=>t.map((e)=>wi.value_of(e,...this.currentContextGlobals)),enumerable:!0}):e[n]=t}object(){let e,n={},t=this.ch;if('{'===t){if(this.next('{'),t=this.white(),'}'===t)return t=this.next('}'),n;for(;t;){if(e='"'===t||'\''===t||'`'===t?this.string():this.name(),this.white(),t=this.next(':'),Object.hasOwnProperty.call(n,e)&&this.error('Duplicate key "'+e+'"'),this.objectAddValue(n,e,this.expression()),t=this.white(),'}'===t)return t=this.next('}'),n;this.next(','),t=this.white()}}this.error('Bad object')}/**
 * Read up to delim and return the string
 * @param  {string} delim The delimiter, either ' or "
 * @return {string}       The string read.
 */readString(e){for(let n,t,i,o='',a=[''],s=Ii['+'],d='`'===e,r=this.next();r;){if(r===e)return r=this.next(),d&&a.push(s),a.push(o),a;if('\\'!==r)d&&'$'===r?(r=this.next(),'{'===r?(this.next('{'),a.push(s),a.push(o),a.push(s),a.push(this.expression()),o=''):o+='$'+r):o+=r;else if(r=this.next(),'u'===r){for(i=0,t=0;4>t&&(n=parseInt(r=this.next(),16),!!isFinite(n));t+=1)i=16*i+n;o+=String.fromCharCode(i)}else if('string'==typeof Li[r])o+=Li[r];else break;r=this.next()}this.error('Bad string')}string(){var e=this.ch;return'"'===e?this.readString('"').join(''):'\''===e?this.readString('\'').join(''):'`'===e?wi.create_root(this.readString('`')):void this.error('Bad string')}array(){let e=[],n=this.ch;if('['===n){if(n=this.next('['),this.white(),']'===n)return n=this.next(']'),e;for(;n;){if(e.push(this.expression()),n=this.white(),']'===n)return n=this.next(']'),e;this.next(','),n=this.white()}}this.error('Bad array')}value(){var e;return this.white(),e=this.ch,'{'===e?this.object():'['===e?this.array():'"'===e||'\''===e||'`'===e?this.string():'-'===e?this.number():'0'<=e&&'9'>=e?this.number():this.identifier()}/**
 * Get the function for the given operator.
 * A `.precedence` value is added to the function, with increasing
 * precedence having a higher number.
 * @return {function} The function that performs the infix operation
 */operator(e){let n,t='',i=this.white(),o=Vi.is_valid_start_char;for(;i&&!(o(i)||' '>=i||''===i||'"'===i||'\''===i||'{'===i||'('===i||'`'===i||')'===i||'9'>=i&&'0'<=i)&&(e.not_an_array||'['!==i)&&(t+=i,i=this.next(),'@'!==i);)o=Vi.is_valid_continue_char;return''!==t&&(e.prefix&&'-'===t&&(t='&-'),n=Ii[t],!n&&this.error('Bad operator: \''+t+'\'.')),n}/**
 * Filters
 * Returns what the Node interprets as an "operator".
 * e.g.
 *   <span data-bind="text: name | fit:20 | uppercase"></span>
 */filter(){let e=this.next(),n=[],t=function(e){return e},o=this.name();for(Ct.filters[o]||Ct.onError('Cannot find filter by the name of: '+o),e=this.white();e;){if(':'===e&&(e=this.next(),n.push(this.expression('|'))),'|'===e){t=this.filter();break}if(','===e)break;e=this.white()}var i=function(e,a,s,d,r){for(var l=[e],p=0,i=n.length;p<i;++p)l.push(wi.value_of(n[p],s,d,r));return t(Ct.filters[o].apply(null,l))};// Lowest precedence.
return i.precedence=1,i}/**
 * Parse an expression – builds an operator tree, in something like
 * Shunting-Yard.
 *   See: http://en.wikipedia.org/wiki/Shunting-yard_algorithm
 *
 * @return {function}   A function that computes the value of the expression
 *                      when called or a primitive.
 */expression(e){let n,t=[],o=this.white();for(;o&&(n=this.operator({prefix:!0}),n&&(t.push(void 0),t.push(n),o=this.white()),'('===o?(this.next(),t.push(this.expression()),this.next(')')):t.push(this.value()),o=this.white(),':'!==o&&'}'!==o&&','!==o&&']'!==o&&')'!==o&&''!==o&&'`'!==o&&('|'!==o||'|'!==e));){// filters
if('|'===o&&'|'!==this.lookahead()&&e){t.push(this.filter()),t.push(void 0);break}// infix or postfix operators
if(n=this.operator({not_an_array:!0}),n===Ii['?']){this.ternary(t);break}else n===Ii['.']?(t.push(n),t.push(this.member()),n=null):n===Ii['[']?(t.push(n),t.push(this.expression()),o=this.next(']'),n=null):n&&t.push(n);if(o=this.white(),']'===o||!n&&'('===o)break}if(0!==t.length){var a=this.dereferences();if(1===t.length&&!a.length)return t[0];for(var s,d=0,i=a.length;d<i;++d)s=a[d],s.constructor===Ai?t.push(Ii.call):t.push(Ii['.']),t.push(s);return new Oi(t)}}ternary(e){var n=new Ri;n.yes=this.expression(),this.next(':'),n.no=this.expression(),e.push(Ii['?']),e.push(n)}/**
 * Parse the arguments to a function, returning an Array.
 *
 */funcArguments(){for(let e=[],n=this.next('(');n;){if(n=this.white(),')'===n)return this.next(')'),new Ai(this,e);e.push(this.expression()),n=this.white(),')'!==n&&this.next(',')}this.error('Bad arguments to function')}/**
 * The literal string reference `abc` in an `x.abc` expression.
 */member(){let e='',n=this.white(),t=Vi.is_valid_start_char;for(;n&&!!t(n);)e+=n,n=this.next(),t=Vi.is_valid_continue_char;return e}/**
 * A dereference applies to an identifer, being either a function
 * call "()" or a membership lookup with square brackets "[member]".
 * @return {fn or undefined}  Dereference function to be applied to the
 *                            Identifier
 */dereference(){for(let e,n=this.white();n;){if('('===n)// a(...) function call
return this.funcArguments();if('['===n)return this.next('['),e=this.expression(),this.white(),this.next(']'),e;if('.'===n)return this.next('.'),this.member();break}}dereferences(){let e,n=this.white(),t=[];for(;n&&(e=this.dereference(),void 0!==e);)t.push(e);return t}identifier(){let e='',n=Vi.is_valid_start_char,t=this.white();for(;t&&!!n(t);)e+=t,t=this.next(),n=Vi.is_valid_continue_char;switch(e){case'true':return!0;case'false':return!1;case'null':return null;case'undefined':return;case'function':throw new Error('Knockout: Anonymous functions are no longer supported, but `=>` lambas are.');// return this.anonymous_fn();
}return new Vi(this,e,this.dereferences())}readBindings(){let e,n,t,i={},o=this.ch;for(;o;)e=this.name(),n=this.white(),n&&','!==n?(-1===e.indexOf('.')?(o=this.next(':'),i[e]&&'object'==typeof i[e]&&i[e].constructor===Object?(t=this.expression(!0),'object'!=typeof t||t.constructor!==Object?Ct.onError('Expected plain object for '+e+' value.'):y(i[e],t)):i[e]=this.expression(!0)):(e=e.split('.'),i[e[0]]=i[e[0]]||{},2===e.length?i[e[0]].constructor!==Object&&Ct.onError('Binding '+e[0]+'.'+e[1]+' paired with a non-object.'):Ct.onError('Binding '+e+' should have two parts (a.b).'),o=this.next(':'),this.objectAddValue(i[e[0]],e[1],this.expression(!0))),this.white(),o=this.ch?this.next(','):''):(o=n?this.next(','):'',i[e]=null);return i}valueAsAccessor(e,n,t,i){if(!e)return()=>e;if('function'==typeof e)return e;if(e[wi.isExpressionOrIdentifierSymbol])return()=>wi.value_of(e,n,t,i);if(Array.isArray(e))return()=>e.map((e)=>wi.value_of(e,n,t,i));if('function'!=typeof e)return()=>E(e);throw new Error('Value has cannot be converted to accessor: '+e)}/**
  * Convert result[name] from a value to a function (i.e. `valueAccessor()`)
  * @param  {object} result [Map of top-level names to values]
  * @return {object}        [Map of top-level names to functions]
  *
  * Accessors may be one of (below) constAccessor, identifierAccessor,
  * expressionAccessor, or nodeAccessor.
  */convertToAccessors(e,n,t,i){return v(e,(o,a)=>{a instanceof Vi?Object.defineProperty(e,o,{value:function(e,o){const s=a.get_value(void 0,n,t,i);if(0===arguments.length)return s;return o&&o.onlyIfChanged&&e===s?void 0:a.set_value(e,n,t)}}):e[o]=this.valueAsAccessor(a,n,t,i)}),e}runParse(e,n){this.text=(e||'').trim(),this.at=0,this.ch=' ';try{var t=n();return this.white(),this.ch&&this.error('Syntax Error'),t}catch(n){Ct.onError(n)}}/**
   * Get the bindings as name: accessor()
   * @param  {string} source The binding string to parse.
   * @return {object}        Map of name to accessor function.
   */parse(e,n={},t={},i){if(!e)return()=>null;this.currentContextGlobals=[n,t,i];const o=this.runParse(e,()=>this.readBindings());return this.convertToAccessors(o,n,t,i)}/**
   * Return a function that evaluates and returns the result of the expression.
   */parseExpression(e,n={},t={},i){if(!e)return()=>'';this.currentContextGlobals=[n,t,i];const o=this.runParse(e,()=>this.expression(!0));return this.valueAsAccessor(o,n,t,i)}}/* eslint no-cond-assign: 0 */// The following regular expressions will be used to split an object-literal string into tokens
// These two match strings, either with double quotes or single quotes
var Mi=',"\'{}()/:[\\]',Fi=/"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\/(?:[^\/\\]|\\.)*\/w*|[^\s:,\/][^,"'{}()\/:[\]]*[^\s,"'{}()\/:[\]]|[^\s]/g,ji=/[\])"'A-Za-z0-9_$]+$/,Wi={in:1,return:1,typeof:1};class Ui{set(e,n){'string'==typeof e?this[e]=n:'object'==typeof e?(void 0!==n&&Ct.onError(new Error('Given extraneous `value` parameter (first param should be a string, but it was an object).'+e)),Object.assign(this,e)):Ct.onError(new Error('Given a bad binding handler type: '+e))}/**
   * The handler may have a `.` in it, e.g. `attr.title`, in which case the
   * handler is `attr`.  Otherwise it's the name given
   */get(e){const[n]=e.split('.');return this[n]}}class Hi{constructor(e={}){if(this.constructor===Hi)throw new Error('Provider is an abstract base class.');if(!('FOR_NODE_TYPES'in this))// FOR_NODE_TYPES must return a list of integers corresponding to the
// node.nodeType's that the provider handles.
throw new Error('Providers must have FOR_NODE_TYPES property');this.bindingHandlers=e.bindingHandlers||new Ui,this.globals=e.globals||{}}nodeHasBindings()/* node */{}getBindingAccessors()/* node, context */{}preprocessNode()/* node */{}postProcess()/* node */{}}/**
 * BindingStringProvider is an abstract base class parses a binding string.
 *
 * Children must implement `nodeHasBindings` and `getBindingString`.
 */class Ki extends Hi{/** Call bindingHandler.preprocess on each respective binding string.
   *
   * The `preprocess` property of bindingHandler must be a static
   * function (i.e. on the object or constructor).
   */*processBinding(e,n){// Get the "on" binding from "on.click"
const[t,i]=e.split('.'),o=this.bindingHandlers.get(t);if(o&&o.preprocess){const t=[];n=o.preprocess(n,e,(...e)=>t.push(e));for(const[e,n]of t)yield*this.processBinding(e,n)}else i&&(n=`{${i}:${n}}`);yield`${t}:${n}`}*generateBindingString(e){for(const{key:n,unknown:t,value:i}of bn(e))yield*this.processBinding(n||t,i)}preProcessBindings(e){return Array.from(this.generateBindingString(e)).join(',')}getBindingAccessors(e,n){const t=e&&this.getBindingString(e);if(t){const i=this.preProcessBindings(t);return new $i().parse(i,n,this.globals,e)}}getBindingString(){throw new Error('Overload getBindingString.')}}class Qi extends Ki{get FOR_NODE_TYPES(){return[document.COMMENT_NODE]}getBindingString(e){if(e.nodeType===document.COMMENT_NODE)return ge(e)}nodeHasBindings(e){if(e.nodeType===document.COMMENT_NODE)return ne(e)}}class qi extends Ki{get FOR_NODE_TYPES(){return[document.ELEMENT_NODE]}get BIND_ATTRIBUTE(){return'data-bind'}getBindingString(e){if(e.nodeType===document.ELEMENT_NODE)return e.getAttribute(this.BIND_ATTRIBUTE)}nodeHasBindings(e){if(e.nodeType===document.ELEMENT_NODE)return e.hasAttribute(this.BIND_ATTRIBUTE)}}var zi={},Gi={},Ji={get(e,n){var t=N(Gi,e);t?t.isSynchronousComponent?Je(function(){n(t.definition)}):Me(function(){n(t.definition)}):yn(e,n)},clearCachedDefinition(e){delete Gi[e]},_getFirstResultFromLoaders:xn,loaders:[]},Yi={},Xi={getConfig:function(e,n){var t=Yi.hasOwnProperty(e)?Yi[e]:null;n(t)},loadComponent:function(e,n,t){var i=Sn(e);_n(i,n,function(n){En(e,i,n,t)})},loadTemplate:function(e,n,t){Cn(Sn(e),n,t)},loadViewModel:function(e,n,t){Dn(Sn(e),n,t)}},Zi='createViewModel';// The default loader is responsible for two things:
// 1. Maintaining the default in-memory registry of component configuration objects
//    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))
// 2. Answering requests for components by fetching configuration objects
//    from that default in-memory registry and resolving them into standard
//    component definition objects (of the form { createViewModel: ..., template: ... })
// Custom loaders may override either of these facilities, i.e.,
// 1. To supply configuration objects from some other source (e.g., conventions)
// 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.
Ji.loaders.push(Xi);var eo={// -- Registry --
get:Ji.get,clearCachedDefinition:Ji.clearCachedDefinition,// -- Loader --
register:function(e,n){if(!n)throw new Error('Invalid configuration for '+e);if(Nn(e))throw new Error('Component '+e+' is already registered');Yi[e]=n},isRegistered:Nn,unregister:function(e){delete Yi[e],Ji.clearCachedDefinition(e)},defaultLoader:Xi,// "Privately" expose the underlying config registry for use in old-IE shim
_allRegisteredComponents:Yi,get loaders(){return Ji.loaders},set loaders(e){Ji.loaders=e}};class no extends Hi{get FOR_NODE_TYPES(){return[document.ELEMENT_NODE]}nodeHasBindings(e){return!!this.getComponentNameForNode(e)}getBindingAccessors(e,n){const t=this.getComponentNameForNode(e);if(t){return{component:()=>({name:t,params:this.getComponentParams(e,n)})}}}getComponentNameForNode(e){if(e.nodeType===e.ELEMENT_NODE){const n=P(e);if(eo.isRegistered(n)){const t=n.includes('-');if(t||'[object HTMLUnknownElement]'+e)return n}}}getComponentParams(e,n){const t=new $i(e,n,this.globals),i=(e.getAttribute('params')||'').trim(),o=t.parse(i,n,e);if(!o||0===Object.keys(o).length)return{$raw:{}};const a=x(o,(n)=>cn(n,null,{disposeWhenNodeIsRemoved:e})),s=x(a,(n)=>this.makeParamValue(e,n));return Object.assign({$raw:a},s)}makeParamValue(e,n){const t=n.peek();// Does the evaluation of the parameter value unwrap any observables?
if(!n.isActive())// No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.
// Example: "someVal: firstName, age: 123" (whether or not firstName is an observable/computed)
return t;// Yes it does. Supply a computed property that unwraps both the outer (binding expression)
// level of observability, and any inner (resulting model value) level of observability.
// This means the component doesn't have to worry about multiple unwrapping. If the value is a
// writable observable, the computed will also be writable and pass the value on to the observable.
const i=an(t);return cn({read:()=>tn(n()),write:i?(e)=>n()(e):null,disposeWhenNodeIsRemoved:e})}}/**
 * Convert attributes with ko-* to bindings.
 *
 * e.g.
 * <div ko-visible='value'></div>
 */class to extends Hi{get FOR_NODE_TYPES(){return[document.ELEMENT_NODE]}get PREFIX(){return'ko-'}getBindingAttributesList(e){return e.hasAttributes()?Array.from(e.attributes).filter((e)=>e.name.startsWith(this.PREFIX)):[]}nodeHasBindings(e){return 0<this.getBindingAttributesList(e).length}getBindingAccessors(e,n){return Object.assign({},...this.handlersFromAttributes(e,n))}*handlersFromAttributes(e,n){for(const t of this.getBindingAttributesList(e)){const i=t.name.substr(this.PREFIX.length);yield{[i]:()=>this.getValue(t.value,n,e)}}}getValue(e,n,t){/* FIXME: This duplicates Identifier.prototype.lookup_value; it should
       be refactored into e.g. a BindingContext method */if(e){const i=n.$data;switch(e){case'$element':return t;case'$context':return n;case'this':case'$data':return n.$data;}if(i instanceof Object&&e in i)return i[e];if(e in n)return n[e];if(e in this.globals)return this.globals[e];throw new Error(`The variable '${e} not found.`)}}}class io extends Hi{get FOR_NODE_TYPES(){return this.nodeTypes}constructor(e={}){super(e);const n=e.providers||[];this.nodeTypeMap={},this.nodeTypes=[],this.providers=[],n.forEach((e)=>this.addProvider(e))}addProvider(e){this.providers.push(e),e.bindingHandlers=this.bindingHandlers,e.globals=this.globals;const n=this.nodeTypeMap;for(const t of e.FOR_NODE_TYPES)n[t]||(n[t]=[]),n[t].push(e);this.nodeTypes=Object.keys(this.nodeTypeMap).map((e)=>parseInt(e,10))}providersFor(e){return this.nodeTypeMap[e.nodeType]||[]}nodeHasBindings(e){return this.providersFor(e).some((n)=>n.nodeHasBindings(e))}preprocessNode(e){for(const n of this.providersFor(e)){const t=n.preprocessNode(e);if(t)return t}}*enumerateProviderBindings(e,n){for(const t of this.providersFor(e)){const i=t.getBindingAccessors(e,n)||{};for(const[e,n]of Object.entries(i||{}))yield[e,n]}}getBindingAccessors(e,n){e=this.preprocessNode(e)||e;const t={};for(const[i,o]of this.enumerateProviderBindings(e,n)){if(i in t)throw new Error(`The binding "${i}" is duplicated by multiple providers`);t[i]=o}return t}}const oo=/^([\s\S]*)}}([\s\S]*?)\{\{([\s\S]*)$/,ao=/^([\s\S]*?)\{\{([\s\S]*)}}([\s\S]*)$/,so=/^([^,"'{}()/:[\]\s]+)\s+([^\s:].*)/;class ro{constructor(e){this.text=e}trim(e){return null===e?'':e.trim()}}class lo extends ro{asAttr(e,n,t){return new $i().parseExpression(this.text,e,n,t)()}*textNodeReplacement(e){const n=this.trim(this.text),t=e?e.ownerDocument:document,i=n[0],o=n[n.length-1];var a,s=!0;if('#'===i){'/'===o?a=n.slice(1,-1):(a=n.slice(1),s=!1);const e=a.match(so);e&&(a=e[1]+':'+e[2])}else if('/'===i);else a='{'===i&&'}'===o?'html:'+this.trim(n.slice(1,-1)):'text:'+this.trim(n);a&&(yield t.createComment('ko '+a)),s&&(yield t.createComment('/ko'))}}class po extends ro{asAttr(){return this.text}*textNodeReplacement(){yield document.createTextNode(this.text.replace(/"/g,'\\"'))}}const uo={value:'value',checked:'checked',class:'css'};/**
 *  Interpret {{ }} inside DOM attributes e.g. <div class='{{ classes }}'>
 */class co extends Hi{get FOR_NODE_TYPES(){return[document.ELEMENT_NODE]}constructor(e={}){super(e),this.ATTRIBUTES_TO_SKIP=new Set(e.attributesToSkip||['data-bind']),this.ATTRIBUTES_BINDING_MAP=e.attributesBindingMap||uo}*attributesToInterpolate(e){for(const n of Array.from(e))this.ATTRIBUTES_TO_SKIP.has(n.name)||n.specified&&n.value.includes('{{')&&(yield n)}nodeHasBindings(e){return!this.attributesToInterpolate(e.attributes).next().done}partsTogether(e,n,t,...i){if(1<e.length)return e.map((e)=>tn(e.asAttr(n,this.globals,t))).join('');// It may be a writeable observable e.g. value="{{ value }}".
const o=e[0].asAttr(n,this.globals);return i.length&&o(i[0]),o}attributeBinding(e,n){return[e,n]}*bindingParts(e){for(const n of this.attributesToInterpolate(e.attributes)){const e=Array.from(wn(n.value));e.length&&(yield this.attributeBinding(n.name,e))}}getPossibleDirectBinding(e){const n=this.ATTRIBUTES_BINDING_MAP[e];return n&&this.bindingHandlers.get(e)}*bindingObjects(e,n){for(const[t,i]of this.bindingParts(e,n)){const o=this.getPossibleDirectBinding(t),a=o?t:`attr.${t}`,s=o?(...t)=>this.partsTogether(i,n,e,...t):(...o)=>({[t]:this.partsTogether(i,n,e,...o)});e.removeAttribute(t),yield{[a]:s}}}getBindingAccessors(e,n){return Object.assign({},...this.bindingObjects(e,n))}}/**
 * Interpret {{ }}, {{{ }}}, {{# /}}, and {{# }} ... {{/ }} inside text nodes.
 *
 * This binding must come before the VirtualProvider.
 */class mo extends Hi{get FOR_NODE_TYPES(){return[document.TEXT_NODE]}*textToNodes(e){const n=e.parentNode,t=n&&'TEXTAREA'===n.nodeName,i=e.nodeValue&&e.nodeValue.includes('{{');if(i&&!t)for(const n of wn(e.nodeValue))yield*n.textNodeReplacement(e)}textInterpolation(e){const t=Array.from(this.textToNodes(e));if(0!==t.length){if(e.parentNode){const o=e.parentNode,a=t.length;for(let n=0;n<a;++n)o.insertBefore(t[n],e);o.removeChild(e)}return t}}/**
   * We convert as follows:
   *
   *   {{# ... }} into <!-- ko ... -->
   *   {{/ ... }} into <!-- /ko -->
   *   {{# ... /}} into <!-- ko ... --><!-- /ko -->
   *   {{ ... }} into <!-- ko text: ... --><!-- /ko -->
   *   {{{ ... }}} into <!-- ko html: ... --><!-- /ko -->
   *
   * VirtualProvider can then pick up and do the actual binding.
   */preprocessNode(e){return this.textInterpolation(e)}}var go=$();On.prototype.lookup=function(e,n,t){// short circuits
switch(e){case'$element':return t;case'$context':return this;case'this':case'$data':return this.$data;}const i=this.$data;// instanceof Object covers 1. {}, 2. [], 3. function() {}, 4. new *;  it excludes undefined, null, primitives.
if(i instanceof Object&&e in i)return i[e];if(e in this)return this[e];if(e in n)return n[e];throw new Error(`The variable "${e}" was not found on $data, $context, or globals.`)},On.prototype.createChildContext=function(e,n,t,i){return new On(e,this,n,function(e,n){e.$parentContext=n,e.$parent=n.$data,e.$parents=(n.$parents||[]).slice(0),e.$parents.unshift(e.$parent),t&&t(e)},i)},On.prototype.extend=function(e){// If the parent context references an observable view model, "_subscribable" will always be the
// latest view model object. If not, "_subscribable" isn't set, and we can use the static "$data" value.
return new On(this._subscribable||this.$data,this,null,function(n,t){n.$rawData=t.$rawData,y(n,'function'==typeof e?e():e)})},On.prototype.createStaticChildContext=function(e,n){return this.createChildContext(e,n,null,{exportDependencies:!0})};const ho=I('LifeCycle Subscriptions List'),fo=I('LifeCycle Anchor Node');class bo{// NOTE: For more advanced integration as an ES6 mixin, see e.g.:
// http://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
/**
   * Copy the properties of the LifeCycle class to the target (or its prototype)
   *
   * NOTE: getOwnPropertyNames is needed to copy the non-enumerable properties.
   */static mixInto(e){const n=e.prototype||e,t=bo.prototype;for(let i of Object.getOwnPropertyNames(t))n[i]=t[i]}subscribe(e,n){'string'==typeof n&&(n=this[n].bind(this)),this.addDisposable(e.subscribe(n))}computed(e){if('string'==typeof e)e={read:this[e],write:this[e],owner:this};else if('object'==typeof e);else if('function'==typeof e)e={read:e,write:e};else throw new Error('LifeCycle::computed not given a valid type.');return e.disposeWhenNodeIsRemoved=this[fo],this.addDisposable(cn(e))}addEventListener(...e){const n=e[0].nodeType?e.shift():this[fo],[t,i,o]=e,a='string'==typeof i?this[i].bind(this):i;this.__addEventListener(n,t,a,o)}__addEventListener(e,n,t,i){function o(){e.removeEventListener(n,t)}e.addEventListener(n,t,i),j(e,o),this.addDisposable({dispose:o})}anchorTo(e){j(e,()=>this.dispose()),this[fo]=e}dispose(){const e=this[ho]||[];e.forEach((e)=>e.dispose()),this[ho]=[],this[fo]=null}addDisposable(e){const n=this[ho]||[];if(this[ho]||(this[ho]=n),'function'!=typeof e.dispose)throw new Error('Lifecycle::addDisposable argument missing `dispose`.');return n.push(e),e}}class yo extends bo{constructor(e){super();const{$element:n,valueAccessor:t,allBindings:i,$context:o}=e;Object.assign(this,{valueAccessor:t,allBindings:i,$element:n,$context:o,$data:o.$data}),this.anchorTo(n)}get value(){return this.valueAccessor()}set value(e){return this.valueAccessor(e)}get controlsDescendants(){return!1}static get allowVirtualElements(){return!1}static get isBindingHandlerClass(){return!0}/* Overload this for asynchronous bindings or bindings that recursively
     apply bindings (e.g. components, foreach, template).

     A binding should be complete when it has run through once, notably
     in server-side bindings for pre-rendering.
  */get bindingCompleted(){return!0}static registerAs(e,n=Ct.bindingProviderInstance){n.bindingHandlers.set(e,this)}}/**
 * An AsyncBindingHandler shall call `completeBinding` when the binding
 * is to be considered complete.
 */class vo extends yo{constructor(e){super(e),this.bindingCompletion=new Ct.Promise((e)=>{this.completeBinding=e})}get bindingCompleted(){return this.bindingCompletion}}/**
 * We have no guarantees, for users employing legacy bindings,
 * that it has not been changed with a modification like
 *
 *    ko.bindingHandlers[name] = { init: ...}
 *
 * ... so we have to keep track by way of a map.
 */const xo=window.WeakMap||Map,No=new xo;class Eo extends yo{constructor(n){super(n);const e=this.handler;'function'==typeof e.dispose&&this.addDisposable(e);try{this.initReturn=e.init&&e.init(...this.legacyArgs)}catch(t){n.onError('init',t)}'function'==typeof e.update&&this.computed(()=>{try{e.update(...this.legacyArgs)}catch(t){n.onError('update',t)}})}get legacyArgs(){return[this.$element,this.valueAccessor,this.allBindings,this.$data,this.$context]}get controlsDescendants(){const e=this.initReturn||this.handler||{};return e.controlsDescendantBindings}/**
   * Create a handler instance from the `origin`, which may be:
   *
   * 1. an object (becomes LegacyBindingHandler)
   * 2. a function (becomes LegacyBindingHandler with `init: function`)
   *
   * If given an object (the only kind supported in knockout 3.x and before), it
   * shall draw the `init`, `update`, and `allowVirtualElements` properties
   */static getOrCreateFor(e,n){if(No.has(n))return No.get(n);const t=this.createFor(e,n);return No.set(n,t),t}static createFor(e,n){if('function'==typeof n){const[t,i]=[n,n.dispose];return class extends Eo{get handler(){const e=t.bind(this),n=i?i.bind(this):null;return{init:e,dispose:n}}static get after(){return n.after}static get allowVirtualElements(){return n.allowVirtualElements||Jt[e]}}}if('object'==typeof n)return class extends Eo{get handler(){return n}static get after(){return n.after}static get allowVirtualElements(){return n.allowVirtualElements||Jt[e]}};throw new Error('The given handler is not an appropriate type.')}}/* eslint no-cond-assign: 0 */// The following element types will not be recursed into during binding.
var Co={script:!0,textarea:!0,template:!0},Do=$(),To=$(),_o=$(),So={init:function(e,n,t,i,o){var a=n()||{};v(a,function(a){'string'==typeof a&&G(e,a,function(e){var s,d=n()[a];if(d){try{// Take all the event args, and prefix with the viewmodel
var r=l(arguments);i=o.$data,r.unshift(i),s=d.apply(i,r)}finally{!0!==s&&(e.preventDefault?e.preventDefault():e.returnValue=!1)}var p=!1!==t.get(a+'Bubble');p||(e.cancelBubble=!0,e.stopPropagation&&e.stopPropagation())}})})}},Io={init:So.init,preprocess:function(e,n,t){t(n.replace('on.',''),'=>'+e)}},ko=function(e){return{init:function(n,t,i,o,a){So.init.call(this,n,function(){var n={};return n[e]=t(),n},i,o,a)}}}('click'),wo={aliases:['class'],update:function(e,n){var t=tn(n());null!==t&&'object'==typeof t?v(t,function(n,t){t=tn(t),k(e,n,t)}):(t=T((t||'')+''),k(e,e[wo.classesWrittenByBindingKey],!1),e[wo.classesWrittenByBindingKey]=t,k(e,t,!0))},classesWrittenByBindingKey:I('__ko__cssValue')},Oo={update:function(e,n){var t=tn(n());t&&e.disabled?e.removeAttribute('disabled'):!t&&!e.disabled&&(e.disabled=!0)}},Ao=I('__ko_hasfocusUpdating'),Bo=I('__ko_hasfocusLastValue'),Po={init:function(e,n/*, allBindings */){var t=function(t){e[Ao]=!0;var i=e.ownerDocument;if('activeElement'in i){var o;try{o=i.activeElement}catch(n){o=i.body}t=o===e}// var modelValue = valueAccessor();
n(t,{onlyIfChanged:!0}),e[Bo]=t,e[Ao]=!1},i=t.bind(null,!0),o=t.bind(null,!1);G(e,'focus',i),G(e,'focusin',i),G(e,'blur',o),G(e,'focusout',o)},update:function(e,n){var t=!!tn(n());e[Ao]||e[Bo]===t||(t?e.focus():e.blur(),!t&&e[Bo]&&e.ownerDocument.body.focus(),Je(J,null,[e,t?'focusin':'focusout']))}},Vo='__ko__hasDomDataOptionValue__',Ro={optionsValueDomDataKey:void 0,readValue:function(e){switch(P(e)){case'option':return!0===e[Vo]?Tt(e,Ro.optionValueDomDataKey):e.value;case'select':return 0<=e.selectedIndex?Ro.readValue(e.options[e.selectedIndex]):void 0;default:return e.value;}},writeValue:function(e,t,o){switch(P(e)){case'option':switch(typeof t){case'string':_t(e,Ro.optionValueDomDataKey,void 0),Vo in e&&delete e[Vo],e.value=t;break;default:_t(e,Ro.optionValueDomDataKey,t),e[Vo]=!0,e.value='number'==typeof t?t:'';}break;case'select':(''===t||null===t)&&(t=void 0);for(var a,s=-1,d=0,i=e.options.length;d<i;++d)// Include special check to handle selecting a caption with a blank string value
if(a=Ro.readValue(e.options[d]),a==t||''===a&&void 0===t){s=d;break}(o||0<=s||void 0===t&&1<e.size)&&(e.selectedIndex=s);break;default:(null===t||void 0===t)&&(t=''),e.value=t;}}},Lo={};// 'click' is just a shorthand for the usual full-length event:{click:handler}
// Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
// are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
// that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
Ro.optionValueDomDataKey=$();var $o,Mo,Fo,jo,Wo;// IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.
// But it does fire the 'selectionchange' event on many of those, presumably because the
// cursor is moving and that counts as the selection changing. The 'selectionchange' event is
// fired at the document level only and doesn't directly indicate which element changed. We
// set up just one event handler for the document and use 'activeElement' to determine which
// element was changed.
if(window.navigator&&($o=function(e){if(e)return parseFloat(e[1])},Mo=window.opera&&window.opera.version&&parseInt(window.opera.version()),Fo=window.navigator.userAgent,jo=$o(Fo.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),Wo=$o(Fo.match(/Firefox\/([^ ]*)/))),10>It)var Uo=$(),Ho=$(),Ko=function(e){var n=this.activeElement,t=n&&Tt(n,Ho);t&&t(e)},Qo=function(e,n){var t=e.ownerDocument;Tt(t,Uo)||(_t(t,Uo,!0),G(t,'selectionchange',Ko)),_t(e,Ho,n)};var qo={aliases:'textinput',init:function(n,t){var i,o,a=n.value,s=function(e){clearTimeout(i),o=i=void 0;var s=n.value;a!==s&&(Ct.debug&&e&&(n._ko_textInputProcessedEvent=e.type),a=s,t(s))},d=function(e){if(!i){o=n.value;var t=Ct.debug?s.bind(n,{type:e.type}):s;i=h(t,4)}},r=9===It?d:s,l=function(){var e=tn(t());return(null===e||void 0===e)&&(e=''),void 0!==o&&e===o?void h(l,4):void(n.value!==e&&(a=e,n.value=e));// Update the element only if the element and model are different. On some browsers, updating the value
// will move the cursor to the end of the input, which would be bad while the user is typing.
},p=function(e,t){G(n,e,t)};// IE9 will mess up the DOM if you handle events synchronously which results in DOM changes (such as other bindings);
// so we'll make sure all updates are asynchronous
Ct.debug&&qo._forceUpdateOn?e(qo._forceUpdateOn,function(e){'after'==e.slice(0,5)?p(e.slice(5),d):p(e,s)}):10>It?(p('propertychange',function(e){'value'===e.propertyName&&r(e)}),8==It&&(p('keyup',s),p('keydown',s)),8<=It&&(Qo(n,r),p('dragend',d))):(p('input',s),5>jo&&'textarea'===P(n)?(p('keydown',d),p('paste',d),p('cut',d)):11>Mo?p('keydown',d):4>Wo&&(p('DOMAutoComplete',s),p('dragdrop',s),p('drop',s))),p('change',s),cn(l,null,{disposeWhenNodeIsRemoved:n})}},zo={init:function(e,n){if(n()){var t='ko_unique_'+ ++zo.currentIndex;xe(e,t)}},currentIndex:0},Go={update:function(e,n){var t=tn(n()),i='none'!=e.style.display;t&&!i?e.style.display='':!t&&i&&(e.style.display='none')}},Jo=1,Yo=2,Xo=3,Zo=4;// // textinput is an alias for textInput
// ko.bindingHandlers['textinput'] = {
//     // preprocess is the only way to set up a full alias
//     'preprocess': function (value, name, addBinding) {
//         addBinding('textInput', value);
//     }
// };
// A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
// logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
//
// Two are provided by default:
//  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
//  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
//                                           without reading/writing the actual element text content, since it will be overwritten
//                                           with the rendered template output.
// You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
// Template sources need to have the following functions:
//   text() 			- returns the template text from your storage location
//   text(value)		- writes the supplied template text to your storage location
//   data(key)			- reads values stored using data(key, value) - see below
//   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
//
// Optionally, template sources can also have the following functions:
//   nodes()            - returns a DOM element containing the nodes of this template, where available
//   nodes(value)       - writes the given DOM element to your storage location
// If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
// for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
//
// Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
// using and overriding "makeTemplateSource" to return an instance of your custom template source.
// ---- ko.templateSources.domElement -----
// template types
Xn.prototype.text=function()/* valueToWrite */{var e=this.templateType===Jo?'text':this.templateType===Yo?'value':'innerHTML';if(0==arguments.length)return this.domElement[e];var n=arguments[0];'innerHTML'==e?Ie(this.domElement,n):this.domElement[e]=n};var ea=$()+'_';Xn.prototype.data=function(e/*, valueToWrite */){return 1===arguments.length?Tt(this.domElement,ea+e):void _t(this.domElement,ea+e,arguments[1])};var na=$();Xn.prototype.nodes=function()/* valueToWrite */{var e=this.domElement;if(0==arguments.length){var n=Zn(e),t=n.containerData;return t||(this.templateType===Xo?e.content:this.templateType===Zo?e:void 0)}var i=arguments[0];et(e,{containerData:i})},nt.prototype=new Xn,nt.prototype.constructor=nt,nt.prototype.text=function()/* valueToWrite */{if(0==arguments.length){var e=Zn(this.domElement);return void 0===e.textData&&e.containerData&&(e.textData=e.containerData.innerHTML),e.textData}var n=arguments[0];et(this.domElement,{textData:n})},y(tt.prototype,{renderTemplateSource:function(e,n,t){t.onError('Override renderTemplateSource')},createJavaScriptEvaluatorBlock:function(){Ct.onError('Override createJavaScriptEvaluatorBlock')},makeTemplateSource:function(e,n){// Named template
if('string'==typeof e){n=n||document;var t=n.getElementById(e);return t||Ct.onError('Cannot find template with ID '+e),new Xn(t)}return 1==e.nodeType||8==e.nodeType?new nt(e):void Ct.onError('Unknown template type: '+e)},renderTemplate:function(e,n,t,i){var o=this.makeTemplateSource(e,i);return this.renderTemplateSource(o,n,t,i)}});var ta;let ia=$();class oa extends vo{constructor(e){super(e);const n=this.$element,t=tn(this.value);let i;// Expose 'conditional' for `else` chaining.
// Support anonymous templates
if(_t(n,'conditional',{elseChainSatisfied:Ze(!0)}),'string'==typeof t||t.name)de(n);else if('nodes'in t){// We've been given an array of DOM nodes. Save them as the template source.
// There is no known use case for the node array being an observable array (if the output
// varies, put that behavior *into* your template - that's what templates are for), and
// the implementation would be a mess, so assert that it's not observable.
var o=t.nodes||[];if(nn(o))throw new Error('The "nodes" option must be a plain, non-observable array.');i=fe(o),new nt(n).nodes(i)}else{// It's an anonymous template - store the element contents, then clear the element
const e=se(n);i=fe(e),new nt(n).nodes(i)}this.computed(this.onValueChange.bind(this))}onValueChange(){const e=this.$element,n=this.$context;var t,i=this.value,o=tn(i),a=!0,s=null,d=Tt(e,'conditional').elseChainSatisfied;if('string'==typeof o?(t=i,o={}):(t=o.name,'if'in o&&(a=tn(o.if)),a&&'ifnot'in o&&(a=!tn(o.ifnot))),'foreach'in o){// Render once for each data point (treating data set as empty if shouldDisplay==false)
var r=a&&o.foreach||[];s=pt(t||e,r,o,e,n,this.completeBinding),d(0!==(tn(r)||[]).length)}else if(a){// Render once for this single data point (or use the viewModel if no data was provided)
var l='data'in o?n.createStaticChildContext(o.data,o.as)// Given an explitit 'data' value, we create a child binding context for it
:n;// Given no explicit 'data' value, we retain the same binding context
s=lt(t||e,l,o,e,void 0,this.completeBinding),d(!0)}else de(e),d(!1);// It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)
this.disposeOldComputedAndStoreNewOne(e,s)}disposeOldComputedAndStoreNewOne(e,n){let t=Tt(e,ia);t&&'function'==typeof t.dispose&&t.dispose(),_t(e,ia,n&&n.isActive()?n:void 0)}get controlsDescendants(){return!0}static get allowVirtualElements(){return!0}}ut.prototype=new tt,ut.prototype.constructor=ut,ut.prototype.renderTemplateSource=function(e,n,t,i){var// IE<9 cloneNode doesn't work properly
o=!(9>It)?e.nodes:null,a=o?e.nodes():null;if(a)return l(a.cloneNode(!0).childNodes);var s=e.text();return Se(s,i)},ut.instance=new ut,it(ut.instance);// "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
// "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
class aa extends oa{get value(){const e=this.valueAccessor(),n=on(e);// Unwrap without setting a dependency here
// If unwrappedValue is the array, pass in the wrapped value on its own
// The value will be unwrapped and tracked within the template binding
// (See https://github.com/SteveSanderson/knockout/issues/523)
return n&&'number'!=typeof n.length?(tn(e),{foreach:n.data,as:n.as,includeDestroyed:n.includeDestroyed,afterAdd:n.afterAdd,beforeRemove:n.beforeRemove,afterRender:n.afterRender,beforeMove:n.beforeMove,afterMove:n.afterMove,templateEngine:ut.instance}):{foreach:e,templateEngine:ut.instance};// If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
}}//    'let': letBinding,
//    template: template,
class sa extends vo{constructor(e){super(e),this.hasElse=mt(this.$element);const n=this.completesElseChain=Ze();_t(this.$element,'conditional',{elseChainSatisfied:n}),this.computed(this.render.bind(this))}get elseChainIsAlreadySatisfied(){return!1}get needsRefresh(){return this.isFirstRender||this.shouldDisplayIf!==this.didDisplayOnLastUpdate}get shouldDisplayIf(){return!!tn(this.value)}render(){const e=!this.ifElseNodes;let n=this.shouldDisplayIf,t=this.needsRefresh;this.elseChainIsAlreadySatisfied?(n=!1,t=e||this.didDisplayOnLastUpdate,this.completesElseChain(!0)):this.completesElseChain(this.shouldDisplayIf),t&&(e&&(Ye()||this.hasElse)&&(this.ifElseNodes=gt(this.$element,this.hasElse)),n?(!e||this.hasElse)&&re(this.$element,be(this.ifElseNodes.ifNodes)):this.ifElseNodes?re(this.$element,be(this.ifElseNodes.elseNodes)):de(this.$element),qn(this.bindingContext,this.$element).then(this.completeBinding),this.didDisplayOnLastUpdate=n)}get bindingContext(){return this.$context}get controlsDescendants(){return!0}static get allowVirtualElements(){return!0}}class da extends sa{get shouldDisplayIf(){return!super.shouldDisplayIf}}class ra extends sa{get shouldDisplayIf(){return super.shouldDisplayIf||void 0===this.value}/**
   * Return any conditional that precedes the given node.
   * @return {object}      { elseChainSatisfied: observable }
   */get elseChainIsAlreadySatisfied(){return this._elseChain||(this._elseChain=this.readElseChain()),tn(this._elseChain.elseChainSatisfied)}readElseChain(){let e=this.$element;do e=e.previousSibling;while(e&&1!==e.nodeType&&8!==e.nodeType);return!!e&&(8===e.nodeType&&(e=me(e)),Tt(e,'conditional')||{})}}class la extends sa{get needsRefresh(){return!0}get bindingContext(){return this.$context.createStaticChildContext(this.value)}}const pa=document&&'function'==typeof document.createDocumentFragment,ua=I('_ko_ffe_pending_delete_index');// index.js
// --------
// Fast For Each
//
// Employing sound techniques to make a faster Knockout foreach binding.
// --------
//      Utilities
class ca extends vo{// NOTE: valid valueAccessors include:
//    []
//    observable([])
//    observableArray([])
//    computed
//    {data: array, name: string, as: string}
constructor(e){super(e);const n={};ht(this.value)&&Object.assign(n,this.value),this.noIndex=n.noIndex||this.allBindings.get('noIndex'),this.as=n.as||this.allBindings.get('as'),this.data=n.data||(tn(this.$context.$rawData)===this.value?this.$context.$rawData:this.value),this.container=ne(this.$element)?this.$element.parentNode:this.$element,this.generateContext=this.createContextGenerator(this.as,!this.noIndex),this.noIndex&&(this.updateIndexes=!1),this.templateNode=ft(n.templateNode||(n.name?document.getElementById(n.name).cloneNode(!0):this.$element)),['afterAdd','beforeRemove','afterQueueFlush','beforeQueueFlush'].forEach((e)=>{this[e]=n[e]||this.allBindings.get(e)}),this.changeQueue=[],this.firstLastNodesList=[],this.indexesToDelete=[],this.rendering_queued=!1,this.pendingDeletes=[],this.isNotEmpty=Ze(!!tn(this.data).length),_t(this.$element,'conditional',{elseChainSatisfied:this.isNotEmpty}),de(this.$element);// Prime content
const t=tn(this.data);t.map?this.onArrayChange(t.map(bt),!0):this.completeBinding(),nn(this.data)&&(!this.data.indexOf&&(this.data=this.data.extend({trackArrayChanges:!0})),this.changeSubs=this.data.subscribe(this.onArrayChange,this,'arrayChange'))}dispose(){this.changeSubs&&this.changeSubs.dispose(),this.flushPendingDeletes()}// If the array changes we register the change.
onArrayChange(e,n){// knockout array change notification index handling:
// - sends the original array indexes for deletes
// - sends the new array indexes for adds
// - sorts them all by index in ascending order
// because of this, when checking for possible batch additions, any delete can be between to adds with neighboring indexes, so only additions should be checked
for(var t={added:[],deleted:[]},o=0,i=e.length;o<i;o++){if(t.added.length&&'added'===e[o].status){var a=t.added[t.added.length-1],s=a.isBatch?a.index+a.values.length-1:a.index;if(s+1===e[o].index){a.isBatch||(a={isBatch:!0,status:'added',index:a.index,values:[a.value]},t.added.splice(t.added.length-1,1,a)),a.values.push(e[o].value);continue}}t[e[o].status].push(e[o])}0<t.deleted.length&&(this.changeQueue.push.apply(this.changeQueue,t.deleted),this.changeQueue.push({status:'clearDeletedIndexes'})),this.changeQueue.push.apply(this.changeQueue,t.added),0<this.changeQueue.length&&!this.rendering_queued&&(this.rendering_queued=!0,n?this.processQueue():ca.animateFrame.call(window,()=>this.processQueue()))}startQueueFlush(){'function'==typeof this.beforeQueueFlush&&this.beforeQueueFlush(this.changeQueue)}endQueueFlush(){'function'==typeof this.afterQueueFlush&&this.afterQueueFlush(this.changeQueue)}// Reflect all the changes in the queue in the DOM, then wipe the queue.
processQueue(){var n=!tn(this.data).length,t=9007199254740991;this.startQueueFlush(),e(this.changeQueue,(e)=>{'number'==typeof e.index&&(t=xt(t,e.index)),this[e.status](e)}),this.flushPendingDeletes(),this.rendering_queued=!1,this.updateIndexes&&this.updateIndexes(t),this.endQueueFlush(),this.changeQueue=[],n!=!this.isNotEmpty()&&this.isNotEmpty(!n)}/**
   * Return a function that generates the context for a given node.
   *
   * We generate a single function that reduces our inner-loop calculations,
   * which has a good chance of being optimized by the browser.
   *
   * @param  {string} as  The name given to each item in the list
   * @param  {bool} index Whether to calculate indexes
   * @return {function}   A function(dataValue) that returns the context
   */createContextGenerator(e,n){var t=this.$context;switch((e&&1)|(n&&2)){case 0:// no-as & no-index
return function(e){return t.createChildContext(e,null,yt.bind(this,!1))};case 1:// as + no-index
return function(n){var i={$index:void 0,$list:this.data};return i[e]=n,t.extend(i)};case 2:// no-as + index
return function(e){return t.createChildContext(e,null,yt.bind(this,!0))};case 3:// as + index
return function(n){var i={$index:Ze(),$list:this.data};return i[e]=n,t.extend(i)};}}// Process a changeItem with {status: 'added', ...}
added(e){var n=e.index,t=e.isBatch?e.values:[e.value],o=this.getLastNodeBeforeIndex(n);// gather all childnodes for a possible batch insertion
const a=[],s=[];for(var d,r,l=0,i=t.length;l<i;++l){if(r=this.getPendingDeleteFor(t[l]),r&&r.nodesets.length)d=r.nodesets.pop();else{var p=this.templateNode.cloneNode(!0);// Apply bindings first, and then process child nodes,
// because bindings can add childnodes.
const e=qn(this.generateContext(t[l]),p);s.push(e),d=se(p)}// Note discussion at https://github.com/angular/angular.js/issues/7851
a.push.apply(a,Array.prototype.slice.call(d)),this.firstLastNodesList.splice(n+l,0,{first:d[0],last:d[d.length-1]})}'function'==typeof this.afterAdd?this.afterAdd({nodeOrArrayInserted:this.insertAllAfter(a,o),foreachInstance:this}):this.insertAllAfter(a,o),this.completeBinding(Ct.Promise.all(s))}getNodesForIndex(e){let n=[],t=this.firstLastNodesList[e].first,i=this.firstLastNodesList[e].last;for(n.push(t);t&&t!==i;)t=t.nextSibling,n.push(t);return n}getLastNodeBeforeIndex(e){return 1>e||e-1>=this.firstLastNodesList.length?null:this.firstLastNodesList[e-1].last}/**
   * Get the active (focused) node, if it's a child of the given node.
   */activeChildElement(e){var n=document.activeElement;if(O(n,e))return n}insertAllAfter(e,n){let t,o,a,i=null,s=this.$element;// Poor man's node and array check.
if(void 0===e.nodeType&&void 0===e.length)throw new Error('Expected a single node or a node array');if(void 0!==e.nodeType)return i=this.activeChildElement(e),pe(s,e,n),[e];if(1===e.length)i=this.activeChildElement(e[0]),pe(s,e[0],n);else if(pa){for(t=document.createDocumentFragment(),a=0,o=e.length;a!=o;++a)i=i||this.activeChildElement(e[a]),t.appendChild(e[a]);pe(s,t,n)}else// Nodes are inserted in reverse order - pushed down immediately after
// the last node for the previous item or as the first node of element.
for(a=e.length-1;0<=a;--a){i=i||this.activeChildElement(e[a]);var d=e[a];if(!d)break;pe(s,d,n)}return i&&i.focus(),e}// checks if the deleted data item should be handled with delay for a possible reuse at additions
shouldDelayDeletion(e){return e&&('object'==typeof e||'function'==typeof e)}// gets the pending deletion info for this data item
getPendingDeleteFor(e){var n=e&&e[ua];return void 0===n?null:this.pendingDeletes[n]}// tries to find the existing pending delete info for this data item, and if it can't, it registeres one
getOrCreatePendingDeleteFor(e){var n=this.getPendingDeleteFor(e);return n?n:(n={data:e,nodesets:[]},e[ua]=this.pendingDeletes.length,this.pendingDeletes.push(n),n)}// Process a changeItem with {status: 'deleted', ...}
deleted(e){// if we should delay the deletion of this data, we add the nodeset to the pending delete info object
if(this.shouldDelayDeletion(e.value)){let n=this.getOrCreatePendingDeleteFor(e.value);n.nodesets.push(this.getNodesForIndex(e.index))}else this.removeNodes(this.getNodesForIndex(e.index));this.indexesToDelete.push(e.index)}// removes a set of nodes from the DOM
removeNodes(e){function n(){for(var n=e[0].parentNode,t=e.length-1;0<=t;--t)K(e[t]),n.removeChild(e[t])}if(e.length)if(this.beforeRemove){var t=this.beforeRemove({nodesToRemove:e,foreachInstance:this})||{};// If beforeRemove returns a `then`–able e.g. a Promise, we remove
// the nodes when that thenable completes.  We pass any errors to
// ko.onError.
'function'==typeof t.then&&t.then(n,Ct.onError)}else n()}// flushes the pending delete info store
// this should be called after queue processing has finished, so that data items and remaining (not reused) nodesets get cleaned up
// we also call it on dispose not to leave any mess
flushPendingDeletes(){for(let n=0,t=this.pendingDeletes.length;n!==t;++n){for(var e=this.pendingDeletes[n];e.nodesets.length;)this.removeNodes(e.nodesets.pop());e.data&&void 0!==e.data[ua]&&delete e.data[ua]}this.pendingDeletes=[]}// We batch our deletion of item indexes in our parallel array.
// See brianmhunt/knockout-fast-foreach#6/#8
clearDeletedIndexes(){// We iterate in reverse on the presumption (following the unit tests) that KO's diff engine
// processes diffs (esp. deletes) monotonically ascending i.e. from index 0 -> N.
for(let e=this.indexesToDelete.length-1;0<=e;--e)this.firstLastNodesList.splice(this.indexesToDelete[e],1);this.indexesToDelete=[]}updateIndexes(e){let n;for(let t=e,i=this.firstLastNodesList.length;t<i;++t)n=this.getContextStartingFrom(this.firstLastNodesList[t].first),n&&n.$index(t)}getContextStartingFrom(e){for(let n;e;){if(n=Bn(e),n)return n;e=e.nextSibling}}/**
   * Set whether the binding is always synchronous.
   * Useful during testing.
   */static setSync(e){ca.animateFrame=e?function(e){e()}:window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(e){return window.setTimeout(e,1e3/60)}}get controlsDescendants(){return!0}static get allowVirtualElements(){return!0}/* TODO: Remove; for legacy/testing */static get ForEach(){return this}static get PENDING_DELETE_INDEX_SYM(){return ua}}var ma={foreach:ca};// By default, foreach will be async.
ca.setSync(!1);var ga=String.prototype,ha={};ha.uppercase=function(e){return ga.toUpperCase.call(tn(e))},ha.lowercase=function(e){return ga.toLowerCase.call(tn(e))},ha['default']=function(e,n){return e=tn(e),'function'==typeof e?e:'string'==typeof e?''===ga.trim.call(e)?n:e:null==e||0==e.length?n:e},ha.replace=function(e,n,t){return ga.replace.call(tn(e),n,t)},ha.fit=function(e,n,t,i){if(e=tn(e),n&&(''+e).length>n)switch(t=''+(t||'...'),n-=t.length,e=''+e,i){case'left':return t+e.slice(-n);case'middle':var o=Math.ceil(n/2);return e.substr(0,o)+t+e.slice(o-n);default:return e.substr(0,n)+t;}else return e},ha.json=function(e,n,t){// replacer and space are optional
return JSON.stringify(rn(e),t,n)},ha.number=function(e){return(+tn(e)).toLocaleString()};//
// Binding Handler for Components
//
var fa=0;class ba extends vo{constructor(e){super(e),this.originalChildNodes=l(se(this.$element)),this.computed('computeApplyComponent')}cloneTemplateIntoElement(e,n,t){const i=n.template;if(!i)throw new Error('Component \''+e+'\' has no template');const o=be(i);re(t,o)}createViewModel(e,n,t,i){const o=e.createViewModel;return o?o.call(e,i,{element:n,templateNodes:t}):i;// Template-only component
}computeApplyComponent(){const e=tn(this.value);let n,t;if('string'==typeof e?n=e:(n=tn(e.name),t=tn(e.params)),this.latestComponentName=n,!n)throw new Error('No component name specified');this.loadingOperationId=this.currentLoadingOperationId=++fa,eo.get(n,(e)=>this.applyComponentDefinition(n,t,e))}applyComponentDefinition(e,n,t){// If this is not the current load operation for this element, ignore it.
if(this.currentLoadingOperationId!==this.loadingOperationId||this.latestComponentName!==e)return;// Clean up previous state
this.cleanUpState();const i=this.$element;// Instantiate and bind new component. Implicitly this cleans any old DOM nodes.
if(!t)throw new Error('Unknown component \''+e+'\'');this.cloneTemplateIntoElement(e,t,i);const o=this.createViewModel(t,i,this.originalChildNodes,n),a=this.$context.createChildContext(o,void 0,(e)=>Object.assign(e,{$component:o,$componentTemplateNodes:this.originalChildNodes}));this.currentViewModel=o,qn(a,this.$element).then(this.completeBinding)}cleanUpState(){const e=this.currentViewModel,n=e&&e.dispose;'function'==typeof n&&n.call(e),this.currentViewModel=null,this.currentLoadingOperationId=null}dispose(){this.cleanUpState(),super.dispose()}get controlsDescendants(){return!0}static get allowVirtualElements(){return!0}}var ya={};/* eslint semi: 0 */e(['extend','setTimeout','arrayForEach','arrayFirst','arrayFilter','arrayGetDistinctValues','arrayIndexOf','arrayMap','arrayPushAll','arrayRemoveItem','getFormFields','peekObservable','postJson','parseJson','registerEventHandler','stringifyJson','range','toggleDomNodeCssClass','triggerEvent','unwrapObservable','objectForEach','addOrRemoveItem','setTextContent','domData','parseHtmlFragment','setHtml','compareArrays','setDomNodeChildrenFromArrayMapping'],function(e){ya[e]=ui[e]}),ya.domNodeDisposal={addDisposeCallback:j,otherNodeCleanerFunctions:jt,removeDisposeCallback:H,removeNode:Q},y(ya,{setDomNodeChildrenFromArrayMapping:Yn,unwrapObservable:tn,peekObservable:on});// Create the binding provider and default bindings.
const va=new io({globals:Ct.bindingGlobals,providers:[new co,new mo,new no,new qi,new Qi,new to]});Ct.bindingProviderInstance=va,va.bindingHandlers.set({attr:{update:function(e,n){var t=tn(n())||{};v(t,function(n,t){t=tn(t);// Find the namespace of this attribute, if any.
// Defaulting to `null` should be ok, as
//
//  element.setAttributeNS( null, name, value ) ~ element.setAttribute( name, value )
//  element.removetAttributeNS( null, name ) ~ element.removeAttribute( name )
//
var i=n.indexOf(':'),o=0>i?null:e.lookupNamespaceURI(n.substr(0,i)),a=!1===t||null===t||void 0===t;// To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
// when someProp is a "no value"-like value (strictly null, false, or undefined)
// (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
a?e.removeAttributeNS(o,n):e.setAttributeNS(o,n,t.toString()),'name'===n&&xe(e,a?'':t.toString())})}},checked:{after:['value','attr'],init:function(e,t,i){function o(){// This updates the model value from the view value.
// It runs in response to DOM events (click) and changes in checkedValue.
var n=e.checked,i=g?s():n;// When we're first setting up this computed, don't change any model state.
if(!Xe()&&(!l||n)){var o=Je(t);if(u){var a=c?o.peek():o;m===i?r(a,i,n):(n&&(r(a,i,!0),r(a,m,!1)),m=i),c&&an(o)&&o(a)}else t(i,{onlyIfChanged:!0})}// We can ignore unchecked radio buttons, because some other radio
// button will be getting checked, and that one can take care of updating state.
}function a(){// This updates the view value from the model value.
// It runs in response to changes in the bound (checked) value.
var i=tn(t());e.checked=u?0<=n(i,s()):d?i:s()===i}var s=hn(function(){// Treat "value" like "checkedValue" when it is included with "checked" binding
return i.has('checkedValue')?tn(i.get('checkedValue')):i.has('value')?tn(i.get('value')):e.value}),d='checkbox'==e.type,l='radio'==e.type;// Only bind to check boxes and radio buttons
if(d||l){var p=t(),u=d&&tn(p)instanceof Array,c=!(u&&p.push&&p.splice),m=u?s():void 0,g=l||u;// Set up two computeds to update the binding:
// The first responds to changes in the checkedValue value and to element clicks
cn(o,null,{disposeWhenNodeIsRemoved:e}),G(e,'click',o),cn(a,null,{disposeWhenNodeIsRemoved:e}),p=void 0}}},checkedValue:{update:function(e,n){e.value=tn(n())}},click:ko,css:wo,class:wo,enable:Oo,event:So,disable:{update:function(e,n){Oo.update(e,function(){return!tn(n())})}},hasfocus:Po,hasFocus:Po,hidden:{update:function(e,n){Go.update.call(this,e,function(){return!tn(n())})}},html:{init:function(){// Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
return{controlsDescendantBindings:!0}},//
// Modify internal, per ko.punches and :
//      http://stackoverflow.com/a/15348139
update:function(e,n){Ie(e,n())},allowVirtualElements:!0},let:{init:function(e,n,t,i,o){// Make a modified binding context, with extra properties, and apply it to descendant elements
var a=o.extend(n);return qn(a,e),{controlsDescendantBindings:!0}},allowVirtualElements:!0},on:Io,options:{init:function(e){if('select'!==P(e))throw new Error('options binding applies only to SELECT elements');// Remove all existing <option>s.
for(;0<e.length;)e.remove(0);// Ensures that the binding processor doesn't try to bind the options
return{controlsDescendantBindings:!0}},update:function(e,t,i){function o(){return s(e.options,function(e){return e.selected})}function d(e,n,t){var i=typeof n;return'function'==i?n(e):'string'==i?e[n]:t}// The following functions can run at two different times:
// The first is when the whole array is being updated directly from this binding handler.
// The second is when an observable value for a specific array entry is updated.
// oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.
// By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection
// problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208
function r(t,o){if(v&&h)Ro.writeValue(e,tn(i.get('value')),!0);else if(y.length){// IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
// That's why we first added them without selection. Now it's time to set the selection.
var a=0<=n(y,Ro.readValue(o[0]));X(o[0],a),v&&!a&&Je(J,null,[e,'change'])}}var l,p,u=0==e.length,c=e.multiple,m=!u&&c?e.scrollTop:null,g=tn(t()),h=i.get('valueAllowUnset')&&i.has('value'),f=i.get('optionsIncludeDestroyed'),b={},y=[];h||(c?y=a(o(),Ro.readValue):0<=e.selectedIndex&&y.push(Ro.readValue(e.options[e.selectedIndex]))),g&&('undefined'==typeof g.length&&(g=[g]),p=s(g,function(e){return f||void 0===e||null===e||!tn(e._destroy)}),i.has('optionsCaption')&&(l=tn(i.get('optionsCaption')),null!==l&&void 0!==l&&p.unshift(Lo)));var v=!1;b.beforeRemove=function(n){e.removeChild(n)};var x=r;i.has('optionsAfterRender')&&'function'==typeof i.get('optionsAfterRender')&&(x=function(e,n){r(e,n),Je(i.get('optionsAfterRender'),null,[n[0],e===Lo?void 0:e])}),Yn(e,p,function(n,t,o){o.length&&(y=!h&&o[0].selected?[Ro.readValue(o[0])]:[],v=!0);var a=e.ownerDocument.createElement('option');if(n===Lo)Ne(a,i.get('optionsCaption')),Ro.writeValue(a,void 0);else{// Apply a value to the option element
var s=d(n,i.get('optionsValue'),n);Ro.writeValue(a,tn(s));// Apply some text to the option element
var r=d(n,i.get('optionsText'),s);Ne(a,r)}return[a]},b,x),Je(function(){if(h)Ro.writeValue(e,tn(i.get('value')),!0);else{// Determine if the selection has changed as a result of updating the options list
var n;n=c?y.length&&o().length<y.length:y.length&&0<=e.selectedIndex?Ro.readValue(e.options[e.selectedIndex])!==y[0]:y.length||0<=e.selectedIndex,n&&J(e,'change')}}),ee(e),m&&20<Math.abs(m-e.scrollTop)&&(e.scrollTop=m)}},selectedOptions:{after:['options','foreach'],init:function(n,t){G(n,'change',function(){var i=t(),o=[];e(n.getElementsByTagName('option'),function(e){e.selected&&o.push(Ro.readValue(e))}),t(o)})},update:function(t,i){if('select'!=P(t))throw new Error('values binding applies only to SELECT elements');var o=tn(i()),a=t.scrollTop;o&&'number'==typeof o.length&&e(t.getElementsByTagName('option'),function(e){var t=0<=n(o,Ro.readValue(e));e.selected!=t&&X(e,t)}),t.scrollTop=a}},style:{update:function(e,n){var t=tn(n()||{});v(t,function(n,t){t=tn(t),(null===t||void 0===t||!1===t)&&(t=''),e.style[n]=t})}},submit:{init:function(e,n,t,i,o){if('function'!=typeof n())throw new Error('The value for a submit binding must be a function');G(e,'submit',function(t){var i,a=n();try{i=a.call(o.$data,e)}finally{!0!==i&&(t.preventDefault?t.preventDefault():t.returnValue=!1)}})}},text:{init:function(){// Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).
// It should also make things faster, as we no longer have to consider whether the text node might be bindable.
return{controlsDescendantBindings:!0}},update:function(e,n){Ne(e,n())},allowVirtualElements:!0},textInput:qo,textinput:qo,uniqueName:zo,using:{init:function(e,n,t,i,o){var a=o.createChildContext(n);return qn(a,e),{controlsDescendantBindings:!0}},allowVirtualElements:!0},value:{after:['options','foreach'],init:function(t,i,a){// If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit
if('input'==t.tagName.toLowerCase()&&('checkbox'==t.type||'radio'==t.type))return void Qn(t,{checkedValue:i});// Always catch "change" event; possibly other events too if asked
var s=['change'],r=a.get('valueUpdate'),l=!1,p=null;r&&('string'==typeof r&&(r=[r]),d(s,r),s=o(s));var u=function(){p=null,l=!1;var e=i(),n=Ro.readValue(t);i(n)},c=It&&'input'==t.tagName.toLowerCase()&&'text'==t.type&&'off'!=t.autocomplete&&(!t.form||'off'!=t.form.autocomplete);// Workaround for https://github.com/SteveSanderson/knockout/issues/122
// IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
c&&-1==n(s,'propertychange')&&(G(t,'propertychange',function(){l=!0}),G(t,'focus',function(){l=!1}),G(t,'blur',function(){l&&u()})),e(s,function(e){// The syntax "after<eventname>" means "run the handler asynchronously after the event"
// This is useful, for example, to catch "keydown" events after the browser has updated the control
// (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
var n=u;_(e,'after')&&(n=function(){p=Ro.readValue(t),h(u,0)},e=e.substring(5)),G(t,e,n)});var m=function(){var e=tn(i()),n=Ro.readValue(t);if(null!==p&&e===p)return void h(m,0);if(e!==n)if('select'===P(t)){var o=a.get('valueAllowUnset'),s=function(){Ro.writeValue(t,e,o)};s(),o||e===Ro.readValue(t)?h(s,0):Je(J,null,[t,'change'])}else Ro.writeValue(t,e)};cn(m,null,{disposeWhenNodeIsRemoved:t})}},visible:Go}),va.bindingHandlers.set({foreach:aa,template:oa}),va.bindingHandlers.set({if:class extends sa{},with:la,ifnot:da,unless:da,else:ra,elseif:ra}),va.bindingHandlers.set(ma),va.bindingHandlers.set({each:ma.foreach}),va.bindingHandlers.set({component:ba}),Object.assign(Ct.filters,ha);// Expose the API.
var xa={// --- Top-level ---
version:'4.0.0-alpha3',options:Ct,extenders:mi,filters:Ct.filters,// --- Utilities ---
cleanNode:K,memoization:ai,removeNode:Q,tasks:pi,utils:ya,dependencyDetection:vi,ignoreDependencies:Je,// -- Observable ---
isObservable:nn,isSubscribable:Ke,isWriteableObservable:an,isWritableObservable:an,observable:Ze,observableArray:dn,peek:on,subscribable:He,unwrap:tn,toJS:rn,toJSON:function(e,n,t){// replacer and space are optional
var i=rn(e);return S(i,n,t)},// ... Computed ...
computed:cn,isComputed:function(e){return D(e,cn)},isPureComputed:function(e){return D(e,cn)&&e[Di]&&e[Di].pure},pureComputed:hn,// --- Templates ---
nativeTemplateEngine:ut,renderTemplate:lt,setTemplateEngine:it,templateEngine:tt,templateSources:{domElement:Xn,anonymousTemplate:nt},// --- Binding ---
applyBindingAccessorsToNode:Qn,applyBindings:zn,applyBindingsToDescendants:qn,applyBindingsToNode:function(e,n,t){const i=new Set;var o=Kn(t);return Qn(e,$n(n,o,e),o,i),Ct.Promise.all(i)},bindingHandlers:va.bindingHandlers,bindingProvider:va,contextFor:Bn,dataFor:function(e){var n=Bn(e);return n?n.$data:void 0},getBindingHandler:Pn,BindingHandler:yo,AsyncBindingHandler:vo,virtualElements:Yt,domNodeDisposal:ya.domNodeDisposal,// --- Components ---
components:eo};return xa});
//# sourceMappingURL=ko.min.js.map
